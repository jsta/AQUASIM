C  ---------------------------------------------------------------------
C
C  SUBROUTINE DASSL  -  INTEGRATION OF DIFFERENTIAL-ALGEBRAIC SYSTEMS
C
C  BY LINDA R. PETZOLD, SANDIA NATIONAL LABORATORIES, LIVERMORE, CA
C
C  ---------------------------------------------------------------------
C
C   Changes made for ANSI and C++ Compatipility (Peter Reichert 5.7.91):
C
C  -  SUBROUTINES DASSL, DDAWTS, DDASTP, DDASLV, DDAJAC, DDATRP, DDAINI,
C                 DDANRM,
C                 DGEFA, DGESL, DGBFA, DGBSL, DAXPY, DSCAL, DDOT,
C                 IDAMAX:
C     replacement of dimensions 1 by the correct value or by *
C
C  -  rename of DFLOAT with DBLEI
C
C  -  replacement of hollerith constants with strings in quotes
C
C  -  replacment of XERRWV with a new ANSI-compatible and machine inde-
C     pendent version
C
C  ---------------------------------------------------------------------
C
      SUBROUTINE DASSL(RES,NEQ,T,Y,YPRIME,TOUT,
     *  INFO,RTOL,ATOL,IDID,
     *  RWORK,LRW,IWORK,LIW,RPAR,IPAR,
     *  JAC)
C
C***BEGIN PROLOGUE  DASSL
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***CATEGORY NO.  D2A2
C***KEYWORDS  DIFFERENTIAL/ALGEBRAIC,BACKWARD DIFFERENTIATION FORMULAS
C             IMPLICIT DIFFERENTIAL SYSTEMS
C***AUTHOR  PETZOLD,LINDA R.
C             APPLIED MATHEMATICS DIVISION 8331
C             SANDIA NATIONAL LABORATORIES
C             LIVERMORE, CA.    94550
C***PURPOSE  DIFFERENTIAL/ALGEBRAIC SYSTEM SOLVER
C***DESCRIPTION
C  ---------------------------------------------------------------------
C
C  THIS CODE SOLVES A SYSTEM OF DIFFERENTIAL/
C  ALGEBRAIC EQUATIONS OF THE FORM
C  G(T,Y,YPRIME) = 0.
C
C  SUBROUTINE DASSL USES THE BACKWARD
C  DIFFERENTIATION FORMULAS OF ORDERS ONE
C  THROUGH FIVE TO SOLVE A SYSTEM OF THE ABOVE
C  FORM FOR Y AND YPRIME. VALUES FOR Y
C  AND YPRIME AT THE INITIAL TIME MUST
C  BE GIVEN AS INPUT. THESE VALUES MUST
C  BE CONSISTENT, (THAT IS. IF T,Y,YPRIME
C  ARE THE GIVEN INITIAL VALUES, THEY MUST
C  SATISFY G(T,Y,YPRIME) = 0.)
C  THE SUBROUTINE SOLVES THE SYSTEM FROM T TO TOUT. IT IS
C  EASY TO CONTINUE THE SOLUTION TO GET RESULTS
C  AT ADDITIONAL TOUT. THIS IS THE INTERVAL
C  MODE OF OPERATION. INTERMEDIATE RESULTS CAN
C  ALSO BE OBTAINED EASILY BY USING THE INTERMEDIATE-
C  OUTPUT CAPABILITY.
C
C
C  ------------DESCRIPTION OF ARGUMENTS TO DASSL-----------------------
C  ------------(AN OVERVIEW)--------------------------------------------
C
C  THE PARAMETERS ARE
C
C  RES -- THIS IS A SUBROUTINE WHICH YOU PROVIDE
C         TO DEFINE THE DIFFERENTIAL/ALGEBRAIC
C         SYSTEM
C
C  NEQ -- THIS IS THE NUMBER OF EQUATIONS
C         TO BE SOLVED
C
C  T -- THIS IS THE CURRENT VALUE OF THE
C       INDEPENDENT VARIABLE.
C
C  TOUT -- THIS IS A POINT AT WHICH A SOLUTION
C      IS DESIRED.
C
C  INFO(*) -- THE BASIC TASK OF THE CODE IS
C             TO SOLVE THE SYSTEM FROM T TO
C             TOUT AND RETURN AN ANSWER AT TOUT.
C             INFO(*) IS AN INTEGER ARRAY WHICH IS
C             USED TO COMMUNICATE EXACTLY HOW YOU
C             WANT THIS TASK TO BE CARRIED OUT.
C
C  Y(*) -- THIS ARRAY CONTAINS THE SOLUTION
C          COMPONENTS AT T
C
C  YPRIME(*) -- THIS ARRAY CONTAINS THE DERIVATIVES
C               OF THE SOLUTION COMPONENTS AT T
C
C  RTOL,ATOL -- THESE QUANTITIES REPRESENT
C               ABSOLUTE AND RELATIVE ERROR
C               TOLERANCES WHICH YOU PROVIDE TO INDICATE
C               HOW ACCURATELY YOU WISH THE SOLUTION
C               TO BE COMPUTED. YOU MAY CHOOSE THEM
C               TO BE BOTH SCALARS OR ELSE BOTH
C               VECTORS.
C
C  IDID -- THIS SCALAR QUANTITY IS AN INDICATOR REPORTING
C          WHAT THE CODE DID. YOU MUST MONITOR THIS
C          INTEGER VARIABLE TO DECIDE WHAT ACTION TO
C          TAKE NEXT.
C
C  RWORK(*),LRW -- RWORK(*) IS A REAL WORK ARRAY OF
C                  LENGTH LRW WHICH PROVIDES THE CODE
C                  WITH NEEDED STORAGE SPACE.
C
C  IWORK(*),LIW -- IWORK(*) IS AN INTEGER WORK ARRAY
C                  OF LENGTH LIW WHICH PROVIDES THE CODE
C                  WITH NEEDED STORAGE SPACE.
C
C  RPAR,IPAR -- THESE ARE REAL AND INTEGER PARAMETER
C               ARRAYS WHICH YOU CAN USE FOR
C               COMMUNICATION BETWEEN YOUR CALLING
C               PROGRAM AND THE RES SUBROUTINE
C               (AND THE JAC SUBROUTINE)
C
C  JAC -- THIS IS THE NAME OF A SUBROUTINE WHICH YOU
C         MAY CHOOSE TO PROVIDE FOR DEFINING
C         A MATRIX OF PARTIAL DERIVATIVES
C         DESCRIBED BELOW.
C
C  QUANTITIES WHICH ARE USED AS INPUT ITEMS ARE
C     NEQ,T,Y(*),YPRIME(*),TOUT,INFO(*),
C     RTOL,ATOL,RWORK(1),RWORK(2),RWORK(3),LRW,IWORK(1),
C     IWORK(2),IWORK(3),AND LIW.
C
C  QUANTITIES WHICH MAY BE ALTERED BY THE CODE ARE
C     T,Y(*),YPRIME(*),INFO(1),RTOL,ATOL,
C     IDID,RWORK(*) AND IWORK(*)
C
C  ----------INPUT-WHAT TO DO ON THE FIRST CALL TO DASSL---------------
C
C
C  THE FIRST CALL OF THE CODE IS DEFINED TO BE THE START OF EACH NEW
C  PROBLEM. READ THROUGH THE DESCRIPTIONS OF ALL THE FOLLOWING ITEMS,
C  PROVIDE SUFFICIENT STORAGE SPACE FOR DESIGNATED ARRAYS, SET
C  APPROPRIATE VARIABLES FOR THE INITIALIZATION OF THE PROBLEM, AND
C  GIVE INFORMATION ABOUT HOW YOU WANT THE PROBLEM TO BE SOLVED.
C
C
C  RES -- PROVIDE A SUBROUTINE OF THE FORM
C             SUBROUTINE RES(T,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
C         TO DEFINE THE SYSTEM OF DIFFERENTIAL/ALGEBRAIC
C         EQUATIONS WHICH IS TO BE SOLVED. FOR THE GIVEN VALUES
C         OF T,Y AND YPRIME, THE SUBROUTINE SHOULD
C         RETURN THE RESIDUAL OF THE DIFFERENTIAL/ALGEBRAIC
C         SYSTEM
C             DELTA = G(T,Y,YPRIME)
C         (DELTA(*) IS A VECTOR OF LENGTH NEQ WHICH IS
C         OUTPUT FOR RES.)
C
C         SUBROUTINE RES MUST NOT ALTER T,Y OR YPRIME.
C         YOU MUST DECLARE THE NAME RES IN AN EXTERNAL
C         STATEMENT IN YOUR PROGRAM THAT CALLS DASSL.
C         YOU MUST DIMENSION Y,YPRIME AND DELTA IN RES.
C
C         IRES IS AN INTEGER FLAG WHICH IS ALWAYS EQUAL TO
C         ZERO ON INPUT.  SUBROUTINE RES SHOULD ALTER IRES
C         ONLY IF IT ENCOUNTERS AN ILLEGAL VALUE OF Y OR
C         A STOP CONDITION.  SET IRES = -1 IF AN INPUT VALUE
C         IS ILLEGAL, AND DASSL WILL TRY TO SOLVE THE PROBLEM
C         WITHOUT GETTING IRES = -1.  IF IRES = -2, DASSL
C         WILL RETURN CONTROL TO THE CALLING PROGRAM
C         WITH IDID = -11.
C
C         RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C         YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING PROGRAM
C         AND SUBROUTINE RES. THEY ARE NOT ALTERED BY DASSL. IF YOU
C         DO NOT NEED RPAR OR IPAR, IGNORE THESE PARAMETERS BY TREAT-
C         ING THEM AS DUMMY ARGUMENTS. IF YOU DO CHOOSE TO USE THEM,
C         DIMENSION THEM IN YOUR CALLING PROGRAM AND IN RES AS ARRAYS
C         OF APPROPRIATE LENGTH.
C
C  NEQ -- SET IT TO THE NUMBER OF DIFFERENTIAL EQUATIONS.
C         (NEQ .GE. 1)
C
C  T -- SET IT TO THE INITIAL POINT OF THE INTEGRATION.
C       T MUST BE DEFINED AS A VARIABLE.
C
C  Y(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF THE NEQ SOLUTION
C          COMPONENTS AT THE INITIAL POINT. YOU MUST DIMENSION Y OF
C          LENGTH AT LEAST NEQ IN YOUR CALLING PROGRAM.
C
C  YPRIME(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF
C               THE NEQ FIRST DERIVATIVES OF THE SOLUTION
C               COMPONENTS AT THE INITIAL POINT. YOU
C               MUST DIMENSION YPRIME AT LEAST NEQ
C               IN YOUR CALLING PROGRAM.  IF YOU DO NOT
C               KNOW INITIAL VALUES OF SOME OF THE SOLUTION
C               COMPONENTS, SEE THE EXPLANATION OF INFO(11).
C
C  TOUT - SET IT TO THE FIRST POINT AT WHICH A SOLUTION
C         IS DESIRED. YOU CAN NOT TAKE TOUT = T.
C         INTEGRATION EITHER FORWARD IN T (TOUT .GT. T) OR
C         BACKWARD IN T (TOUT .LT. T) IS PERMITTED.
C
C         THE CODE ADVANCES THE SOLUTION FROM T TO TOUT USING
C         STEP SIZES WHICH ARE AUTOMATICALLY SELECTED SO AS TO
C         ACHIEVE THE DESIRED ACCURACY. IF YOU WISH, THE CODE WILL
C         RETURN WITH THE SOLUTION AND ITS DERIVATIVE AT
C         INTERMEDIATE STEPS (INTERMEDIATE-OUTPUT MODE) SO THAT
C         YOU CAN MONITOR THEM, BUT YOU STILL MUST PROVIDE TOUT IN
C         ACCORD WITH THE BASIC AIM OF THE CODE.
C
C         THE FIRST STEP TAKEN BY THE CODE IS A CRITICAL ONE
C         BECAUSE IT MUST REFLECT HOW FAST THE SOLUTION CHANGES NEAR
C         THE INITIAL POINT. THE CODE AUTOMATICALLY SELECTS AN
C         INITIAL STEP SIZE WHICH IS PRACTICALLY ALWAYS SUITABLE FOR
C         THE PROBLEM. BY USING THE FACT THAT THE CODE WILL NOT STEP
C         PAST TOUT IN THE FIRST STEP, YOU COULD, IF NECESSARY,
C         RESTRICT THE LENGTH OF THE INITIAL STEP SIZE.
C
C         FOR SOME PROBLEMS IT MAY NOT BE PERMISSABLE TO INTEGRATE
C         PAST A POINT TSTOP BECAUSE A DISCONTINUITY OCCURS THERE
C         OR THE SOLUTION OR ITS DERIVATIVE IS NOT DEFINED BEYOND
C         TSTOP. WHEN YOU HAVE DECLARED A TSTOP POINT (SEE INFO(4)
C         AND RWORK(1)), YOU HAVE TOLD THE CODE NOT TO INTEGRATE
C         PAST TSTOP. IN THIS CASE ANY TOUT BEYOND TSTOP IS INVALID
C         INPUT.
C
C  INFO(*) - USE THE INFO ARRAY TO GIVE THE CODE MORE DETAILS ABOUT
C            HOW YOU WANT YOUR PROBLEM SOLVED. THIS ARRAY SHOULD BE
C            DIMENSIONED OF LENGTH 15, THOUGH DASSL USES
C            ONLY THE FIRST NINE ENTRIES. YOU MUST RESPOND TO ALL OF
C            THE FOLLOWING ITEMS WHICH ARE ARRANGED AS QUESTIONS. THE
C            SIMPLEST USE OF THE CODE CORRESPONDS TO ANSWERING ALL
C            QUESTIONS AS YES ,I.E. SETTING ALL ENTRIES OF INFO TO 0.
C
C       INFO(1) - THIS PARAMETER ENABLES THE CODE TO INITIALIZE
C              ITSELF. YOU MUST SET IT TO INDICATE THE START OF EVERY
C              NEW PROBLEM.
C
C          **** IS THIS THE FIRST CALL FOR THIS PROBLEM ...
C                YES - SET INFO(1) = 0
C                 NO - NOT APPLICABLE HERE.
C                      SEE BELOW FOR CONTINUATION CALLS.  ****
C
C       INFO(2) - HOW MUCH ACCURACY YOU WANT OF YOUR SOLUTION
C              IS SPECIFIED BY THE ERROR TOLERANCES RTOL AND ATOL.
C              THE SIMPLEST USE IS TO TAKE THEM BOTH TO BE SCALARS.
C              TO OBTAIN MORE FLEXIBILITY, THEY CAN BOTH BE VECTORS.
C              THE CODE MUST BE TOLD YOUR CHOICE.
C
C          **** ARE BOTH ERROR TOLERANCES RTOL, ATOL SCALARS ...
C                YES - SET INFO(2) = 0
C                      AND INPUT SCALARS FOR BOTH RTOL AND ATOL
C                 NO - SET INFO(2) = 1
C                      AND INPUT ARRAYS FOR BOTH RTOL AND ATOL ****
C
C       INFO(3) - THE CODE INTEGRATES FROM T IN THE DIRECTION
C              OF TOUT BY STEPS. IF YOU WISH, IT WILL RETURN THE
C              COMPUTED SOLUTION AND DERIVATIVE AT THE NEXT
C              INTERMEDIATE STEP (THE INTERMEDIATE-OUTPUT MODE) OR
C              TOUT, WHICHEVER COMES FIRST. THIS IS A GOOD WAY TO
C              PROCEED IF YOU WANT TO SEE THE BEHAVIOR OF THE SOLUTION.
C              IF YOU MUST HAVE SOLUTIONS AT A GREAT MANY SPECIFIC
C              TOUT POINTS, THIS CODE WILL COMPUTE THEM EFFICIENTLY.
C
C          **** DO YOU WANT THE SOLUTION ONLY AT
C                TOUT (AND NOT AT THE NEXT INTERMEDIATE STEP) ...
C                 YES - SET INFO(3) = 0
C                  NO - SET INFO(3) = 1 ****
C
C       INFO(4) - TO HANDLE SOLUTIONS AT A GREAT MANY SPECIFIC
C              VALUES TOUT EFFICIENTLY, THIS CODE MAY INTEGRATE PAST
C              TOUT AND INTERPOLATE TO OBTAIN THE RESULT AT TOUT.
C              SOMETIMES IT IS NOT POSSIBLE TO INTEGRATE BEYOND SOME
C              POINT TSTOP BECAUSE THE EQUATION CHANGES THERE OR IT IS
C              NOT DEFINED PAST TSTOP. THEN YOU MUST TELL THE CODE
C              NOT TO GO PAST.
C
C           **** CAN THE INTEGRATION BE CARRIED OUT WITHOUT ANY
C                RESTRICTIONS ON THE INDEPENDENT VARIABLE T ...
C                 YES - SET INFO(4)=0
C                  NO - SET INFO(4)=1
C                       AND DEFINE THE STOPPING POINT TSTOP BY
C                       SETTING RWORK(1)=TSTOP ****
C
C       INFO(5) - TO SOLVE DIFFERENTIAL/ALGEBRAIC PROBLEMS IT IS
C              NECESSARY TO USE A MATRIX OF PARTIAL DERIVATIVES OF THE
C              SYSTEM OF DIFFERENTIAL EQUATIONS.  IF YOU DO NOT
C              PROVIDE A SUBROUTINE TO EVALUATE IT ANALYTICALLY (SEE
C              DESCRIPTION OF THE ITEM JAC IN THE CALL LIST), IT WILL
C              BE APPROXIMATED BY NUMERICAL DIFFERENCING IN THIS CODE.
C              ALTHOUGH IT IS LESS TROUBLE FOR YOU TO HAVE THE CODE
C              COMPUTE PARTIAL DERIVATIVES BY NUMERICAL DIFFERENCING,
C              THE SOLUTION WILL BE MORE RELIABLE IF YOU PROVIDE THE
C              DERIVATIVES VIA JAC. SOMETIMES NUMERICAL DIFFERENCING
C              IS CHEAPER THAN EVALUATING DERIVATIVES IN JAC AND
C              SOMETIMES IT IS NOT - THIS DEPENDS ON YOUR PROBLEM.
C
C           **** DO YOU WANT THE CODE TO EVALUATE THE PARTIAL
C                  DERIVATIVES AUTOMATICALLY BY NUMERICAL DIFFERENCES ...
C                   YES - SET INFO(5)=0
C                    NO - SET INFO(5)=1
C                  AND PROVIDE SUBROUTINE JAC FOR EVALUATING THE
C                  MATRIX OF PARTIAL DERIVATIVES ****
C
C       INFO(6) - DASSL WILL PERFORM MUCH BETTER IF THE MATRIX OF
C              PARTIAL DERIVATIVES, DG/DY + CJ*DG/DYPRIME,
C              (HERE CJ IS A SCALAR DETERMINED BY DASSL)
C              IS BANDED AND THE CODE IS TOLD THIS. IN THIS
C              CASE, THE STORAGE NEEDED WILL BE GREATLY REDUCED,
C              NUMERICAL DIFFERENCING WILL BE PERFORMED MUCH CHEAPER,
C              AND A NUMBER OF IMPORTANT ALGORITHMS WILL EXECUTE MUCH
C              FASTER. THE DIFFERENTIAL EQUATION IS SAID TO HAVE
C              HALF-BANDWIDTHS ML (LOWER) AND MU (UPPER) IF EQUATION I
C              INVOLVES ONLY UNKNOWNS Y(J) WITH
C                             I-ML .LE. J .LE. I+MU
C              FOR ALL I=1,2,...,NEQ. THUS, ML AND MU ARE THE WIDTHS
C              OF THE LOWER AND UPPER PARTS OF THE BAND, RESPECTIVELY,
C              WITH THE MAIN DIAGONAL BEING EXCLUDED. IF YOU DO NOT
C              INDICATE THAT THE EQUATION HAS A BANDED MATRIX OF PARTIAL
C                 DERIVATIVES
C              THE CODE WORKS WITH A FULL MATRIX OF NEQ**2 ELEMENTS
C              (STORED IN THE CONVENTIONAL WAY). COMPUTATIONS WITH
C              BANDED MATRICES COST LESS TIME AND STORAGE THAN WITH
C              FULL MATRICES IF  2*ML+MU .LT. NEQ.  IF YOU TELL THE
C              CODE THAT THE MATRIX OF PARTIAL DERIVATIVES HAS A BANDED
C              STRUCTURE AND YOU WANT TO PROVIDE SUBROUTINE JAC TO
C              COMPUTE THE PARTIAL DERIVATIVES, THEN YOU MUST BE CAREFUL
C              TO STORE THE ELEMENTS OF THE MATRIX IN THE SPECIAL FORM
C              INDICATED IN THE DESCRIPTION OF JAC.
C
C          **** DO YOU WANT TO SOLVE THE PROBLEM USING A FULL
C               (DENSE) MATRIX (AND NOT A SPECIAL BANDED
C               STRUCTURE) ...
C                YES - SET INFO(6)=0
C                 NO - SET INFO(6)=1
C                       AND PROVIDE THE LOWER (ML) AND UPPER (MU)
C                       BANDWIDTHS BY SETTING
C                       IWORK(1)=ML
C                       IWORK(2)=MU ****
C
C
C        INFO(7) -- YOU CAN SPECIFY A MAXIMUM (ABSOLUTE VALUE OF)
C              STEPSIZE, SO THAT THE CODE
C              WILL AVOID PASSING OVER VERY
C              LARGE REGIONS.
C
C          ****  DO YOU WANT THE CODE TO DECIDE
C                ON ITS OWN MAXIMUM STEPSIZE?
C                YES - SET INFO(7)=0
C                 NO - SET INFO(7)=1
C                      AND DEFINE HMAX BY SETTING
C                      RWORK(2)=HMAX ****
C
C        INFO(8) -- DIFFERENTIAL/ALGEBRAIC PROBLEMS
C              MAY OCCAISIONALLY SUFFER FROM
C              SEVERE SCALING DIFFICULTIES ON THE
C              FIRST STEP. IF YOU KNOW A GREAT DEAL
C              ABOUT THE SCALING OF YOUR PROBLEM, YOU CAN
C              HELP TO ALLEVIATE THIS PROBLEM BY
C              SPECIFYING AN INITIAL STEPSIZE HO.
C
C          ****  DO YOU WANT THE CODE TO DEFINE
C                ITS OWN INITIAL STEPSIZE?
C                YES - SET INFO(8)=0
C                 NO - SET INFO(8)=1
C                      AND DEFINE HO BY SETTING
C                      RWORK(3)=HO ****
C
C        INFO(9) -- IF STORAGE IS A SEVERE PROBLEM,
C              YOU CAN SAVE SOME LOCATIONS BY
C              RESTRICTING THE MAXIMUM ORDER MAXORD.
C              THE DEFAULT VALUE IS 5. FOR EACH
C              ORDER DECREASE BELOW 5, THE CODE
C              REQUIRES NEQ FEWER LOCATIONS, HOWEVER
C              IT IS LIKELY TO BE SLOWER. IN ANY
C              CASE, YOU MUST HAVE 1 .LE. MAXORD .LE. 5
C          ****  DO YOU WANT THE MAXIMUM ORDER TO
C                DEFAULT TO 5?
C                YES - SET INFO(9)=0
C                 NO - SET INFO(9)=1
C                      AND DEFINE MAXORD BY SETTING
C                      IWORK(3)=MAXORD ****
C
C        INFO(10) --IF YOU KNOW THAT THE SOLUTIONS TO YOUR EQUATIONS WILL
C               ALWAYS BE NONNEGATIVE, IT MAY HELP TO SET THIS
C               PARAMETER.  HOWEVER, IT IS PROBABLY BEST TO
C               TRY THE CODE WITHOUT USING THIS OPTION FIRST,
C               AND ONLY TO USE THIS OPTION IF THAT DOESN'T
C               WORK VERY WELL.
C           ****  DO YOU WANT THE CODE TO SOLVE THE PROBLEM WITHOUT
C                 INVOKING ANY SPECIAL NONNEGATIVITY CONSTRAINTS?
C                  YES - SET INFO(10)=0
C                   NO - SET INFO(10)=1
C
C        INFO(11) --DASSL NORMALLY REQUIRES THE INITIAL T,
C               Y, AND YPRIME TO BE CONSISTENT.  THAT IS,
C               YOU MUST HAVE G(T,Y,YPRIME) = 0 AT THE INITIAL
C               TIME.  IF YOU DO NOT KNOW THE INITIAL
C               DERIVATIVE PRECISELY, YOU CAN LET DASSL TRY
C               TO COMPUTE IT.
C          ****   ARE THE INITIAL T, Y, YPRIME CONSISTENT?
C                 YES - SET INFO(11) = 0
C                  NO - SET INFO(11) = 1,
C                       AND SET YPRIME TO AN INITIAL APPROXIMATION
C                       TO YPRIME.  (IF YOU HAVE NO IDEA WHAT
C                       YPRIME SHOULD BE, SET IT TO ZERO. NOTE
C                       THAT THE INITIAL Y SHOULD BE SUCH
C                       THAT THERE MUST EXIST A YPRIME SO THAT
C                       G(T,Y,YPRIME) = 0.)
C
C   RTOL, ATOL -- YOU MUST ASSIGN RELATIVE (RTOL) AND ABSOLUTE (ATOL
C               ERROR TOLERANCES TO TELL THE CODE HOW ACCURATELY YOU WANT
C               THE SOLUTION TO BE COMPUTED. THEY MUST BE DEFINED AS
C               VARIABLES BECAUSE THE CODE MAY CHANGE THEM. YOU HAVE TWO
C               CHOICES --
C                     BOTH RTOL AND ATOL ARE SCALARS. (INFO(2)=0)
C                     BOTH RTOL AND ATOL ARE VECTORS. (INFO(2)=1)
C               IN EITHER CASE ALL COMPONENTS MUST BE NON-NEGATIVE.
C
C               THE TOLERANCES ARE USED BY THE CODE IN A LOCAL ERROR TEST
C               AT EACH STEP WHICH REQUIRES ROUGHLY THAT
C                     ABS(LOCAL ERROR) .LE. RTOL*ABS(Y)+ATOL
C               FOR EACH VECTOR COMPONENT.
C               (MORE SPECIFICALLY, A ROOT-MEAN-SQUARE NORM IS USED TO
C               MEASURE THE SIZE OF VECTORS, AND THE ERROR TEST USES THE
C               MAGNITUDE OF THE SOLUTION AT THE BEGINNING OF THE STEP.)
C
C               THE TRUE (GLOBAL) ERROR IS THE DIFFERENCE BETWEEN THE TRUE
C               SOLUTION OF THE INITIAL VALUE PROBLEM AND THE COMPUTED
C               APPROXIMATION. PRACTICALLY ALL PRESENT DAY CODES.
C               INCLUDING THIS ONE, CONTROL THE LOCAL ERROR AT EACH STEP
C               AND DO NOT EVEN ATTEMPT TO CONTROL THE GLOBAL ERROR
C               DIRECTLY.
C               USUALLY, BUT NOT ALWAYS, THE TRUE ACCURACY OF
C               THE COMPUTED Y IS COMPARABLE TO THE ERROR TOLERANCES. THIS
C               CODE WILL USUALLY, BUT NOT ALWAYS, DELIVER A MORE ACCURATE
C               SOLUTION IF YOU REDUCE THE TOLERANCES AND INTEGRATE AGAIN.
C               BY COMPARING TWO SUCH SOLUTIONS YOU CAN GET A FAIRLY
C               RELIABLE IDEA OF THE TRUE ERROR IN THE SOLUTION AT THE
C               BIGGER TOLERANCES.
C
C               SETTING ATOL=0. RESULTS IN A PURE RELATIVE ERROR TEST ON
C               THAT COMPONENT. SETTING RTOL=0. RESULTS IN A PURE ABSOLUTE
C               ERROR TEST ON THAT COMPONENT. A MIXED TEST WITH NON-ZERO
C               RTOL AND ATOL CORRESPONDS ROUGHLY TO A RELATIVE ERROR
C               TEST WHEN THE SOLUTION COMPONENT IS MUCH BIGGER THAN ATOL
C               AND TO AN ABSOLUTE ERROR TEST WHEN THE SOLUTION COMPONENT
C               IS SMALLER THAN THE THRESHOLD ATOL.
C
C               THE CODE WILL NOT ATTEMPT TO COMPUTE A SOLUTION AT AN
C               ACCURACY UNREASONABLE FOR THE MACHINE BEING USED. IT WILL
C               ADVISE YOU IF YOU ASK FOR TOO MUCH ACCURACY AND INFORM
C               YOU AS TO THE MAXIMUM ACCURACY IT BELIEVES POSSIBLE.
C
C  RWORK(*) -- DIMENSION THIS REAL WORK ARRAY OF LENGTH LRW IN YOUR
C               CALLING PROGRAM.
C
C  LRW -- SET IT TO THE DECLARED LENGTH OF THE RWORK ARRAY.
C               YOU MUST HAVE
C                    LRW .GE. 40+(MAXORD+4)*NEQ+NEQ**2
C               FOR THE FULL (DENSE) JACOBIAN CASE (WHEN INFO(6)=0),  OR
C                    LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
C               FOR THE BANDED USER-DEFINED JACOBIAN CASE
C               (WHEN INFO(5)=1 AND INFO(6)=1), OR
C                     LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
C                           +2*(NEQ/(ML+MU+1)+1)
C               FOR THE BANDED FINITE-DIFFERENCE-GENERATED JACOBIAN CASE
C               (WHEN INFO(5)=0 AND INFO(6)=1)
C
C  IWORK(*) -- DIMENSION THIS INTEGER WORK ARRAY OF LENGTH LIW IN
C             YOUR CALLING PROGRAM.
C
C  LIW -- SET IT TO THE DECLARED LENGTH OF THE IWORK ARRAY.
C               YOU MUST HAVE LIW .GE. 20+NEQ
C
C  RPAR, IPAR -- THESE ARE PARAMETER ARRAYS, OF REAL AND INTEGER
C               TYPE, RESPECTIVELY. YOU CAN USE THEM FOR COMMUNICATION
C               BETWEEN YOUR PROGRAM THAT CALLS DASSL AND THE
C               RES SUBROUTINE (AND THE JAC SUBROUTINE). THEY ARE NOT
C               ALTERED BY DASSL. IF YOU DO NOT NEED RPAR OR IPAR, IGNORE
C               THESE PARAMETERS BY TREATING THEM AS DUMMY ARGUMENTS. IF
C               YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN YOUR CALLING
C               PROGRAM AND IN RES (AND IN JAC) AS ARRAYS OF APPROPRIATE
C               LENGTH.
C
C  JAC -- IF YOU HAVE SET INFO(5)=0, YOU CAN IGNORE THIS PARAMETER
C               BY TREATING IT AS A DUMMY ARGUMENT. OTHERWISE, YOU MUST
C               PROVIDE A SUBROUTINE OF THE FORM
C               JAC(T,Y,YPRIME,PD,CJ,RPAR,IPAR)
C               TO DEFINE THE MATRIX OF PARTIAL DERIVATIVES
C               PD=DG/DY+CJ*DG/DYPRIME
C               CJ IS A SCALAR WHICH IS INPUT TO JAC.
C               FOR THE GIVEN VALUES OF T,Y,YPRIME, THE
C               SUBROUTINE MUST EVALUATE THE NON-ZERO PARTIAL
C               DERIVATIVES FOR EACH EQUATION AND EACH SOLUTION
C               COMPOWENT, AND STORE THESE VALUES IN THE
C               MATRIX PD. THE ELEMENTS OF PD ARE SET TO ZERO
C               BEFORE EACH CALL TO JAC SO ONLY NON-ZERO ELEMENTS
C               NEED TO BE DEFINED.
C
C               SUBROUTINE JAC MUST NOT ALTER T,Y,(*),YPRIME(*),OR CJ.
C               YOU MUST DECLARE THE NAME JAC IN AN
C               EXTERNAL STATEMENT IN YOUR PROGRAM THAT CALLS
C               DASSL. YOU MUST DIMENSION Y, YPRIME AND PD
C               IN JAC.
C
C               THE WAY YOU MUST STORE THE ELEMENTS INTO THE PD MATRIX
C               DEPENDS ON THE STRUCTURE OF THE MATRIX WHICH YOU
C               INDICATED BY INFO(6).
C               *** INFO(6)=0 -- FULL (DENSE) MATRIX ***
C                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C               STORE IT IN PD ACCORDING TO
C                   PD(I,J) = * DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)*
C               *** INFO(6)=1 -- BANDED JACOBIAN WITH ML LOWER AND MU
C                   UPPER DIAGONAL BANDS (REFER TO INFO(6) DESCRIPTION OF
C                   ML AND MU) ***
C                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
C                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
C                   STORE IT IN PD ACCORDING TO
C                   IROW = I - J + ML + MU + 1
C                   PD(IROW,J) = *DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)*
C               RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C               YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING
C               PROGRAM AND YOUR JACOBIAN SUBROUTINE JAC. THEY ARE NOT
C               ALTERED BY DASSL. IF YOU DO NOT NEED RPAR OR IPAR, IGNORE
C               THESE PARAMETERS BY TREATING THEM AS DUMMY ARGUMENTS. IF
C               YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN YOUR CALLING
C               PROGRAM AND IN JAC AS ARRAYS OF APPROPRIATE LENGTH.
C
C
C
C  OPTIONALLY REPLACEABLE NORM ROUTINE:
C  DASSL USES A WEIGHTED NORM DDANRM TO MEASURE THE SIZE
C  OF VECTORS SUCH AS THE ESTIMATED ERROR IN EACH STEP.
C  A FUNCTION SUBPROGRAM
C    DOUBLE PRECISION FUNCTION DDANRM(NEQ,V,WT,RPAR,IPAR)
C    DIMENSION V(NEQ),WT(NEQ)
C  IS USED TO DEFINE THIS NORM.  HERE, V IS THE VECTOR
C  WHOSE NORM IS TO BE COMPUTED, AND WT IS A VECTOR OF
C  WEIGHTS.  A DDANRM ROUTINE HAS BEEN INCLUDED WITH DASSL
C  WHICH COMPUTES THE WEIGHTED ROOT-MEAN-SQUARE NORM
C  GIVEN BY
C    DDANRM=SQRT((1/NEQ)*SUM(V(I)/WT(I))**2)
C  THIS NORM IS SUITABLE FOR MOST PROBLEMS.  IN SOME
C  SPECIAL CASES, IT MAY BE MORE CONVENIENT AND/OR
C  EFFICIENT TO DEFINE YOUR OWN NORM BY WRITING A FUNCTION
C  SUBPROGRAM TO BE CALLED INSTEAD OF DDANRM.  THIS SHOULD
C  HOWEVER, BE ATTEMPTED ONLY AFTER CAREFUL THOUGHT AND
C  CONSIDERATION.
C
C
C------OUTPUT-AFTER ANY RETURN FROM DASSL----
C
C  THE PRINCIPAL AIM OF THE CODE IS TO RETURN A COMPUTED SOLUTION AT
C  TOUT, ALTHOUGH IT IS ALSO POSSIBLE TO OBTAIN INTERMEDIATE RESULTS
C  ALONG THE WAY. TO FIND OUT WHETHER THE CODE ACHIEVED ITS GOAL
C  OR IF THE INTEGRATION PROCESS WAS INTERRUPTED BEFORE THE TASK WAS
C  COMPLETED, YOU MUST CHECK THE IDID PARAMETER.
C
C
C   T -- THE SOLUTION WAS SUCCESSFULLY ADVANCED TO THE
C               OUTPUT VALUE OF T.
C
C   Y(*) -- CONTAINS THE COMPUTED SOLUTION APPROXIMATION AT T.
C
C   YPRIME(*) -- CONTAINS THE COMPUTED DERIVATIVE
C               APPROXIMATION AT T
C
C   IDID -- REPORTS WHAT THE CODE DID
C
C                     *** TASK COMPLETED ***
C                REPORTED BY POSITIVE VALUES OF IDID
C
C           IDID = 1 -- A STEP WAS SUCCESSFULLY TAKEN IN THE
C                   INTERMEDIATE-OUTPUT MODE. THE CODE HAS NOT
C                   YET REACHED TOUT.
C
C           IDID = 2 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
C                   COMPLETED (T=TOUT) BY STEPPING EXACTLY TO TOUT.
C
C           IDID = 3 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
C                   COMPLETED (T=TOUT) BY STEPPING PAST TOUT.
C                   Y(*) IS OBTAINED BY INTERPOLATION.
C                   YPRIME(*) IS OBTAINED BY INTERPOLATION.
C
C                    *** TASK INTERRUPTED ***
C                REPORTED BY NEGATIVE VALUES OF IDID
C
C           IDID = -1 -- A LARGE AMOUNT OF WORK HAS BEEN EXPENDED.
C                   (ABOUT 500 STEPS)
C
C           IDID = -2 -- THE ERROR TOLERANCES ARE TOO STRINGENT.
C
C           IDID = -3 -- THE LOCAL ERROR TEST CANNOT BE SATISFIED
C                   BECAUSE YOU SPECIFIED A ZERO COMPONENT IN ATOL
C                   AND THE CORRESPONDING COMPUTED SOLUTION
C                   COMPONENT IS ZERO. THUS, A PURE RELATIVE ERROR
C                   TEST IS IMPOSSIBLE FOR THIS COMPONENT.
C
C           IDID = -6 -- DASSL HAD REPEATED ERROR TEST
C                   FAILURES ON THE LAST ATTEMPTED STEP.
C
C           IDID = -7 -- THE CORRECTOR COULD NOT CONVERGE.
C
C           IDID = -8 -- THE MATRIX OF PARTIAL DERIVATIVES
C                   IS SINGULAR.
C
C           IDID = -9 -- THE CORRECTOR COULD NOT CONVERGE.
C                   THERE WERE REPEATED ERROR TEST FAILURES
C                   IN THIS STEP.
C
C           IDID =-10 -- THE CORRECTOR COULD NOT CONVERGE
C                   BECAUSE IRES WAS EQUAL TO MINUS ONE.
C
C           IDID =-11 -- IRES EQUAL TO -2 WAS ENCOUNTERED
C                   AND CONTROL IS BEING RETURNED TO THE
C                   CALLING PROGRAM.
C
C           IDID =-12 -- DASSL FAILED TO COMPUTE THE INITIAL
C                   YPRIME.
C
C
C
C           IDID = -13,..,-32 -- NOT APPLICABLE FOR THIS CODE
C
C                    *** TASK TERMINATED ***
C                REPORTED BY THE VALUE OF IDID=-33
C
C           IDID = -33 -- THE CODE HAS ENCOUNTERED TROUBLE FROM WHICH
C                   IT CANNOT RECOVER. A MESSAGE IS PRINTED
C                   EXPLAINING THE TROUBLE AND CONTROL IS RETURNED
C                   TO THE CALLING PROGRAM. FOR EXAMPLE, THIS OCCURS
C                   WHEN INVALID INPUT IS DETECTED.
C
C   RTOL, ATOL -- THESE QUANTITIES REMAIN UNCHANGED EXCEPT WHEN
C               IDID = -2. IN THIS CASE, THE ERROR TOLERANCES HAVE BEEN
C               INCREASED BY THE CODE TO VALUES WHICH ARE ESTIMATED TO BE
C               APPROPRIATE FOR CONTINUING THE INTEGRATION. HOWEVER, THE
C               REPORTED SOLUTION AT T WAS OBTAINED USING THE INPUT VALUES
C               OF RTOL AND ATOL.
C
C   RWORK, IWORK -- CONTAIN INFORMATION WHICH IS USUALLY OF NO
C               INTEREST TO THE USER BUT NECESSARY FOR SUBSEQUENT CALLS.
C               HOWEVER, YOU MAY FIND USE FOR
C
C               RWORK(3)--WHICH CONTAINS THE STEP SIZE H TO BE
C                       ATTEMPTED ON THE NEXT STEP.
C
C               RWORK(4)--WHICH CONTAINS THE CURRENT VALUE OF THE
C                       INDEPENDENT VARIABLE, I.E. THE FARTHEST POINT
C                       INTEGRATION HAS REACHED. THIS WILL BE DIFFERENT
C                       FROM T ONLY WHEN INTERPOLATION HAS BEEN
C                       PERFORMED (IDID=3).
C
C               RWORK(7)--WHICH CONTAINS THE STEPSIZE USED
C                       ON THE LAST SUCCESSFUL STEP.
C
C               IWORK(7)--WHICH CONTAINS THE ORDER OF THE METHOD TO
C                       BE ATTEMPTED ON THE NEXT STEP.
C
C               IWORK(8)--WHICH CONTAINS THE ORDER OF THE METHOD USED
C                       ON THE LAST STEP.
C
C               IWORK(11)--WHICH CONTAINS THE NUMBER OF STEPS TAKEN SO FAR.
C
C               IWORK(12)--WHICH CONTAINS THE NUMBER OF CALLS TO RES
C                        SO FAR.
C
C               IWORK(13)--WHICH CONTAINS THE NUMBER OF EVALUATIONS OF
C                        THE MATRIX OF PARTIAL DERIVATIVES NEEDED SO FAR.
C
C               IWORK(14)--WHICH CONTAINS THE TOTAL NUMBER
C                        OF ERROR TEST FAILURES SO FAR.
C
C               IWORK(15)--WHICH CONTAINS THE TOTAL NUMBER
C                        OF CONVERGENCE TEST FAILURES SO FAR.
C                        (INCLUDES SINGULAR ITERATION MATRIX
C                        FAILURES.)
C
C
C
C   INPUT -- WHAT TO DO TO CONTINUE THE INTEGRATION
C            (CALLS AFTER THE FIRST)                **
C
C     THIS CODE IS ORGANIZED SO THAT SUBSEQUENT CALLS TO CONTINUE THE
C     INTEGRATION INVOLVE LITTLE (IF ANY) ADDITIONAL EFFORT ON YOUR
C     PART. YOU MUST MONITOR THE IDID PARAMETER IN ORDER TO DETERMINE
C     WHAT TO DO NEXT.
C
C     RECALLING THAT THE PRINCIPAL TASK OF THE CODE IS TO INTEGRATE
C     FROM T TO TOUT (THE INTERVAL MODE), USUALLY ALL YOU WILL NEED
C     TO DO IS SPECIFY A NEW TOUT UPON REACHING THE CURRENT TOUT.
C
C     DO NOT ALTER ANY QUANTITY NOT SPECIFICALLY PERMITTED BELOW,
C     IN PARTICULAR DO NOT ALTER NEQ,T,Y(*),YPRIME(*),RWORK(*),IWORK(*)
C     OR THE DIFFERENTIAL EQUATION IN SUBROUTINE RES. ANY SUCH
C     ALTERATION CONSTITUTES A NEW PROBLEM AND MUST BE TREATED AS SUCH,
C     I.E. YOU MUST START AFRESH.
C
C     YOU CANNOT CHANGE FROM VECTOR TO SCALAR ERROR CONTROL OR VICE
C     VERSA (INFO(2)) BUT YOU CAN CHANGE THE SIZE OF THE ENTRIES OF
C     RTOL, ATOL. INCREASING A TOLERANCE MAKES THE EQUATION EASIER
C     TO INTEGRATE. DECREASING A TOLERANCE WILL MAKE THE EQUATION
C     HARDER TO INTEGRATE AND SHOULD GENERALLY BE AVOIDED.
C
C     YOU CAN SWITCH FROM THE INTERMEDIATE-OUTPUT MODE TO THE
C     INTERVAL MODE (INFO(3)) OR VICE VERSA AT ANY TIME.
C
C     IF IT HAS BEEN NECESSARY TO PREVENT THE INTEGRATION FROM GOING
C     PAST A POINT TSTOP (INFO(4), RWORK(1)), KEEP IN MIND THAT THE
C     CODE WILL NOT INTEGRATE TO ANY TOUT BEYOUND THE CURRENTLY
C     SPECIFIED TSTOP. ONCE TSTOP HAS BEEN REACHED YOU MUST CHANGE
C     THE VALUE OF TSTOP OR SET INFO(4)=0. YOU MAY CHANGE INFO(4)
C     OR TSTOP AT ANY TIME BUT YOU MUST SUPPLY THE VALUE OF TSTOP IN
C     RWORK(1) WHENEVER YOU SET INFO(4)=1.
C
C     DO NOT CHANGE INFO(5), INFO(6), IWORK(1), OR IWORK(2)
C     UNLESS YOU ARE GOING TO RESTART THE CODE.
C
C                    *** FOLLOWING A COMPLETED TASK ***
C     IF
C     IDID = 1, CALL THE CODE AGAIN TO CONTINUE THE INTEGRATION
C                  ANOTHER STEP IN THE DIRECTION OF TOUT.
C
C     IDID = 2 OR 3, DEFINE A NEW TOUT AND CALL THE CODE AGAIN.
C                  TOUT MUST BE DIFFERENT FROM T. YOU CANNOT CHANGE
C                  THE DIRECTION OF INTEGRATION WITHOUT RESTARTING.
C
C                    *** FOLLOWING AN INTERRUPTED TASK ***
C                  TO SHOW THE CODE THAT YOU REALIZE THE TASK WAS
C                  INTERRUPTED AND THAT YOU WANT TO CONTINUE, YOU
C                  MUST TAKE APPROPRIATE ACTION AND SET INFO(1) = 1
C     IF
C     IDID = -1, THE CODE HAS TAKEN ABOUT 500 STEPS.
C                  IF YOU WANT TO CONTINUE, SET INFO(1) = 1 AND
C                  CALL THE CODE AGAIN. AN ADDITIONAL 500 STEPS
C                  WILL BE ALLOWED.
C
C
C     IDID = -2, THE ERROR TOLERANCES RTOL, ATOL HAVE BEEN
C                  INCREASED TO VALUES THE CODE ESTIMATES APPROPRIATE
C                  FOR CONTINUING. YOU MAY WANT TO CHANGE THEM
C                  YOURSELF. IF YOU ARE SURE YOU WANT TO CONTINUE
C                  WITH RELAXED ERROR TOLERANCES, SET INFO(1)=1 AND
C                  CALL THE CODE AGAIN.
C
C     IDID = -3, A SOLUTION COMPONENT IS ZERO AND YOU SET THE
C                  CORRESPONDING COMPONENT OF ATOL TO ZERO. IF YOU
C                  ARE SURE YOU WANT TO CONTINUE, YOU MUST FIRST
C                  ALTER THE ERROR CRITERION TO USE POSITIVE VALUES
C                  FOR THOSE COMPONENTS OF ATOL CORRESPONDING TO ZERO
C                  SOLUTION COMPONENTS, THEN SET INFO(1)=1 AND CALL
C                  THE CODE AGAIN.
C
C     IDID = -4,-5  --- CANNOT OCCUR WITH THIS CODE
C
C     IDID = -6, REPEATED ERROR TEST FAILURES OCCURRED ON THE
C                  LAST ATTEMPTED STEP IN DASSL  . A SINGULARITY IN THE
C                  SOLUTION MAY BE PRESENT. IF YOU ARE ABSOLUTELY
C                  CERTAIN YOU WANT TO CONTINUE, YOU SHOULD RESTART
C                  THE INTEGRATION.(PROVIDE INITIAL VALUES OF Y AND
C                  YPRIME WHICH ARE CONSISTENT)
C
C     IDID = -7, REPEATED CONVERGENCE TEST FAILURES OCCURRED
C                  ON THE LAST ATTEMPTED STEP IN DASSL. AN INACCURATE OR
C                  ILLCONDITIONED JACOBIAN MAY BE THE PROBLEM. IF YOU
C                  ARE ABSOLUTELY CERTAIN YOU WANT TO CONTINUE, YOU
C                  SHOULD RESTART THE INTEGRATION.
C
C     IDID = -8, THE MATRIX OF PARTIAL DERIVATIVES IS SINGULAR.
C                  SOME OF YOUR EQUATIONS MAY BE REDUNDANT.
C                  DASSL CANNOT SOLVE THE PROBLEM AS STATED.
C                  IT IS POSSIBLE THAT THE REDUNDANT EQUATIONS
C                  COULD BE REMOVED, AND THEN DASSL COULD
C                  SOLVE THE PROBLEM. IT IS ALSO POSSIBLE
C                  THAT A SOLUTION TO YOUR PROBLEM EITHER
C                  DOES NOT EXIST OR IS NOT UNIQUE.
C
C     IDID = -9, DASSL HAD MULTIPLE CONVERGENCE TEST
C                  FAILURES, PRECEEDED BY MULTIPLE ERROR
C                  TEST FAILURES, ON THE LAST ATTEMPTED STEP.
C                  IT IS POSSIBLE THAT YOUR PROBLEM
C                  IS ILL-POSED, AND CANNOT BE SOLVED
C                  USING THIS CODE.  OR, THERE MAY BE A
C                  DISCONTINUITY OR A SINGULARITY IN THE
C                  SOLUTION.  IF YOU ARE ABSOLUTELY CERTAIN
C                  YOU WANT TO CONTINUE, YOU SHOULD RESTART
C                  THE INTEGRATION.
C
C    IDID =-10, DASSL HAD MULTIPLE CONVERGENCE TEST FAILURES
C                  BECAUSE IRES WAS EQUAL TO MINUS ONE.
C                  IF YOU ARE ABSOLUTELY CERTAIN YOU WANT
C                  TO CONTINUE, YOU SHOULD RESTART THE
C                  INTEGRATION.
C
C    IDID =-11, IRES=-2 WAS ENCOUNTERED, AND CONTROL IS BEING
C                  RETURNED TO THE CALLING PROGRAM.
C
C    IDID =-12, DASSL FAILED TO COMPUTE THE INITIAL YPRIME.
C               THIS COULD HAPPEN BECAUSE THE INITIAL
C               APPROXIMATION TO YPRIME WAS NOT VERY GOOD, OR
C               IF A YPRIME CONSISTENT WITH THE INITIAL Y
C               DOES NOT EXIST.  THE PROBLEM COULD ALSO BE CAUSED
C               BY AN INACCURATE OR SINGULAR ITERATION MATRIX.
C
C
C
C     IDID = -13,..,-32 --- CANNOT OCCUR WITH THIS CODE
C
C                       *** FOLLOWING A TERMINATED TASK ***
C     IF IDID= -33, YOU CANNOT CONTINUE THE SOLUTION OF THIS
C                  PROBLEM. AN ATTEMPT TO DO SO WILL RESULT IN YOUR
C                  RUN BEING TERMINATED.
C
C  ---------------------------------------------------------------------
C
C***REFERENCES  A DESCRIPTION OF DASSL: A DIFFERENTIAL/ALGEBRAIC
C                  SYSTEM SOLVER, L. R. PETZOLD, SAND82-8637,
C                  SANDIA NATIONAL LABORATORIES, SEPTEMBER 1982.
C***ROUTINES CALLED  DDASTP,DDAINI,DDANRM,DDAWTS,DDATRP,XERRWV,D1MACH
C***COMMON BLOCKS    DDA001
C***END PROLOGUE DASSL
C
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL DONE
      EXTERNAL RES,JAC
      DIMENSION Y(NEQ),YPRIME(NEQ)
      DIMENSION INFO(15)
      DIMENSION RWORK(LRW),IWORK(LIW)
      DIMENSION RTOL(NEQ),ATOL(NEQ)
      DIMENSION RPAR(*),IPAR(*)
      COMMON/DDA001/NPD,NTEMP,
     *   LML,LMU,LMXORD,LMTYPE,
     *   LNST,LNRE,LNJE,LETF,LCTF,LIPVT
      DATA LTSTOP,LHMAX,LH,LTN,
     *   LCJ,LCJOLD,LHOLD,LS,LROUND,
     *   LALPHA,LBETA,LGAMMA,
     *   LPSI,LSIGMA,LDELTA
     *   /1,2,3,4,
     *   5,6,7,8,9,
     *   11,17,23,
     *   29,35,41/
      IF(INFO(1).NE.0)GO TO 100
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED FOR THE INITIAL CALL ONLY.
C     IT CONTAINS CHECKING OF INPUTS AND INITIALIZATIONS.
C-----------------------------------------------------------------------
C
C     FIRST CHECK INFO ARRAY TO MAKE SURE ALL ELEMENTS OF INFO
C     ARE EITHER ZERO OR ONE.
      DO 10 I=2,11
         IF(INFO(I).NE.0.AND.INFO(I).NE.1)GO TO 701
10       CONTINUE
C
      IF(NEQ.LE.0)GO TO 702
C
C     SET POINTERS INTO IWORK
      LML=1
      LMU=2
      LMXORD=3
      LMTYPE=4
      LJCALC=5
      LPHASE=6
      LK=7
      LKOLD=8
      LNS=9
      LNSTL=10
      LNST=11
      LNRE=12
      LNJE=13
      LETF=14
      LCTF=15
      LIPVT=21
      LIWM=1
C
C     CHECK AND COMPUTE MAXIMUM ORDER
      MXORD=5
      IF(INFO(9).EQ.0)GO TO 20
         MXORD=IWORK(LMXORD)
         IF(MXORD.LT.1.OR.MXORD.GT.5)GO TO 703
20       IWORK(LMXORD)=MXORD
C
C     COMPUTE MTYPE,LENPD,LENRW.CHECK ML AND MU.
      IF(INFO(6).NE.0)GO TO 40
         LENPD=NEQ*NEQ
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD
         IF(INFO(5).NE.0)GO TO 30
            IWORK(LMTYPE)=2
            GO TO 60
30          IWORK(LMTYPE)=1
            GO TO 60
40    IF(IWORK(LML).LT.0.OR.IWORK(LML).GE.NEQ)GO TO 717
      IF(IWORK(LMU).LT.0.OR.IWORK(LMU).GE.NEQ)GO TO 718
      LENPD=(2*IWORK(LML)+IWORK(LMU)+1)*NEQ
      IF(INFO(5).NE.0)GO TO 50
         IWORK(LMTYPE)=5
         MBAND=IWORK(LML)+IWORK(LMU)+1
         MSAVE=(NEQ/MBAND)+1
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD+2*MSAVE
         GO TO 60
50       IWORK(LMTYPE)=4
         LENRW=40+(IWORK(LMXORD)+4)*NEQ+LENPD
C
C     CHECK LENGTHS OF RWORK AND IWORK
60    LENIW=20+NEQ
      IF(LRW.LT.LENRW)GO TO 704
      IF(LIW.LT.LENIW)GO TO 705
C
C     CHECK TO SEE THAT TOUT IS DIFFERENT FROM T
      IF(TOUT .EQ. T)GO TO 719
C
C     CHECK HMAX
      IF(INFO(7).EQ.0)GO TO 70
         HMAX=RWORK(LHMAX)
         IF(HMAX.LE.0.0D0)GO TO 710
70    CONTINUE
C
C     INITIALIZE COUNTERS
      IWORK(LNST)=0
      IWORK(LNRE)=0
      IWORK(LNJE)=0
C
      IWORK(LNSTL)=0
      IDID=1
      GO TO 200
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS FOR CONTINUATION CALLS
C     ONLY. HERE WE CHECK INFO(1),AND IF THE
C     LAST STEP WAS INTERRUPTED WE CHECK WHETHER
C     APPROPRIATE ACTION WAS TAKEN.
C-----------------------------------------------------------------------
C
100   CONTINUE
      IF(INFO(1).EQ.1)GO TO 110
      IF(INFO(1).NE.-1)GO TO 701
C     IF WE ARE HERE, THE LAST STEP WAS INTERRUPTED
C     BY AN ERROR CONDITION FROM DDASTP,AND
C     APPROPRIATE ACTION WAS NOT TAKEN. THIS
C     IS A FATAL ERROR.
      CALL XERRWV(
     *'DASSL--  THE LAST STEP TERMINATED WITH A NEGATIVE',
     *49,201,0,0,0,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  VALUE (=I1) OF IDID AND NO APPROPRIATE',
     *47,202,0,1,IDID,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  ACTION WAS TAKEN. RUN TERMINATED',
     *41,203,1,0,0,0,0,0.0D0,0.0D0)
      RETURN
110   CONTINUE
      IWORK(LNSTL)=IWORK(LNST)
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED ON ALL CALLS.
C     THE ERROR TOLERANCE PARAMETERS ARE
C     CHECKED, AND THE WORK ARRAY POINTERS
C     ARE SET.
C-----------------------------------------------------------------------
C
200   CONTINUE
C     CHECK RTOL,ATOL
      NZFLG=0
      RTOLI=RTOL(1)
      ATOLI=ATOL(1)
      DO 210 I=1,NEQ
         IF(INFO(2).EQ.1)RTOLI=RTOL(I)
         IF(INFO(2).EQ.1)ATOLI=ATOL(I)
         IF(RTOLI.GT.0.0D0.OR.ATOLI.GT.0.0D0)NZFLG=1
         IF(RTOLI.LT.0.0D0)GO TO 706
         IF(ATOLI.LT.0.0D0)GO TO 707
210      CONTINUE
      IF(NZFLG.EQ.0)GO TO 708
C
C     SET UP RWORK STORAGE.IWORK STORAGE IS FIXED
C     IN DATA STATEMENT.
      LE=LDELTA+NEQ
      LWT=LE+NEQ
      LPHI=LWT+NEQ
      LPD=LPHI+(IWORK(LMXORD)+1)*NEQ
      LWM=LPD
      NPD=1
      NTEMP=NPD+LENPD
      IF(INFO(1).EQ.1)GO TO 400
C
C-----------------------------------------------------------------------
C     THIS BLOCK IS EXECUTED ON THE INITIAL CALL
C     ONLY. SET THE INITIAL STEP SIZE, AND
C     THE ERROR WEIGHT VECTOR, AND PHI.
C     COMPUTE INITIAL YPRIME, IF NECESSARY.
C-----------------------------------------------------------------------
C
300   CONTINUE
      TN=T
      IDID=1
C
C     SET ERROR WEIGHT VECTOR WT
      CALL DDAWTS(NEQ,INFO(2),RTOL,ATOL,Y,RWORK(LWT),RPAR,IPAR)
      DO 305 I = 1,NEQ
         IF(RWORK(LWT+I-1).LE.0.0D0) GO TO 713
305      CONTINUE
C
C     COMPUTE UNIT ROUNDOFF AND HMIN
      UROUND = D1MACH(4)
      RWORK(LROUND) = UROUND
      HMIN = 4.0D0*UROUND*DMAX1(DABS(T),DABS(TOUT))
C
C     CHECK INITIAL INTERVAL TO SEE THAT IT IS LONG ENOUGH
      TDIST = DABS(TOUT - T)
      IF(TDIST .LT. HMIN) GO TO 714
C
C     CHECK HO, IF THIS WAS INPUT
      IF (INFO(8) .EQ. 0) GO TO 310
         HO = RWORK(LH)
         IF ((TOUT - T)*HO .LT. 0.0D0) GO TO 711
         IF (HO .EQ. 0.0D0) GO TO 712
         GO TO 320
310    CONTINUE
C
C     COMPUTE INITIAL STEPSIZE, TO BE USED BY EITHER
C     DDASTP OR DDAINI, DEPENDING ON INFO(11)
      HO = 0.001D0*TDIST
      YPNORM = DDANRM(NEQ,YPRIME,RWORK(LWT),RPAR,IPAR)
      IF (YPNORM .GT. 0.5D0/HO) HO = 0.5D0/YPNORM
      HO = DSIGN(HO,TOUT-T)
C     ADJUST HO IF NECESSARY TO MEET HMAX BOUND
320   IF (INFO(7) .EQ. 0) GO TO 330
         RH = DABS(HO)/HMAX
         IF (RH .GT. 1.0D0) HO = HO/RH
C     COMPUTE TSTOP, IF APPLICABLE
330   IF (INFO(4) .EQ. 0) GO TO 340
         TSTOP = RWORK(LTSTOP)
         IF ((TSTOP - T)*HO .LT. 0.0D0) GO TO 715
         IF ((T + HO - TSTOP)*HO .GT. 0.0D0) HO = TSTOP - T
         IF ((TSTOP - TOUT)*HO .LT. 0.0D0) GO TO 709
C
C     COMPUTE INITIAL DERIVATIVE, IF APPLICABLE
340   IF (INFO(11) .EQ. 0) GO TO 350
      CALL DDAINI(T,Y,YPRIME,NEQ,
     *  RES,JAC,HO,RWORK(LWT),IDID,RPAR,IPAR,
     *  RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
     *  RWORK(LWM),IWORK(LIWM),HMIN,RWORK(LROUND),INFO(10))
      IF (IDID .LT. 0) GO TO 390
C
C     LOAD H WITH HO.  STORE H IN RWORK(LH)
350   H = HO
      RWORK(LH) = H
C
C     LOAD Y AND H*YPRIME INTO PHI(*,1) AND PHI(*,2)
360   ITEMP = LPHI + NEQ
      DO 370 I = 1,NEQ
         RWORK(LPHI + I - 1) = Y(I)
370      RWORK(ITEMP + I - 1) = H*YPRIME(I)
C
390   GO TO 500
C
C-------------------------------------------------------
C     THIS BLOCK IS FOR CONTINUATION CALLS ONLY. ITS
C     PURPOSE IS TO CHECK STOP CONDITIONS BEFORE
C     TAKING A STEP.
C     ADJUST H IF NECESSARY TO MEET HMAX BOUND
C-------------------------------------------------------
C
400   CONTINUE
      DONE = .FALSE.
      TN=RWORK(LTN)
      H=RWORK(LH)
      IF(INFO(7) .EQ. 0) GO TO 410
         RH = DABS(H)/HMAX
         IF(RH .GT. 1.0D0) H = H/RH
410   CONTINUE
      IF(T .EQ. TOUT) GO TO 719
      IF((T - TOUT)*H .GT. 0.0D0) GO TO 711
      IF(INFO(4) .EQ. 1) GO TO 430
      IF(INFO(3) .EQ. 1) GO TO 420
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 490
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
420   IF((TN-T)*H .LE. 0.0D0) GO TO 490
      IF((TN - TOUT)*H .GT. 0.0D0) GO TO 425
      CALL DDATRP(TN,TN,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TN
      IDID = 1
      DONE = .TRUE.
      GO TO 490
425   CONTINUE
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
430   IF(INFO(3) .EQ. 1) GO TO 440
      TSTOP=RWORK(LTSTOP)
      IF((TN-TSTOP)*H.GT.0.0D0) GO TO 715
      IF((TSTOP-TOUT)*H.LT.0.0D0)GO TO 709
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 450
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *   RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
440   TSTOP = RWORK(LTSTOP)
      IF((TN-TSTOP)*H .GT. 0.0D0) GO TO 715
      IF((TSTOP-TOUT)*H .LT. 0.0D0) GO TO 709
      IF((TN-T)*H .LE. 0.0D0) GO TO 450
      IF((TN - TOUT)*H .GT. 0.0D0) GO TO 445
      CALL DDATRP(TN,TN,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TN
      IDID = 1
      DONE = .TRUE.
      GO TO 490
445   CONTINUE
      CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,IWORK(LKOLD),
     *  RWORK(LPHI),RWORK(LPSI))
      T = TOUT
      IDID = 3
      DONE = .TRUE.
      GO TO 490
450   CONTINUE
C     CHECK WHETHER WE ARE WITH IN ROUNDOFF OF TSTOP
      IF(DABS(TN-TSTOP).GT.100.0D0*UROUND*
     *   (DABS(TN)+DABS(H)))GO TO 460
      IDID=2
      T=TSTOP
      DONE = .TRUE.
      GO TO 490
460   TNEXT=TN+H*(1.0D0+4.0D0*UROUND)
      IF((TNEXT-TSTOP)*H.LE.0.0D0)GO TO 490
      H=(TSTOP-TN)*(1.0D0-4.0D0*UROUND)
      RWORK(LH)=H
C
490   IF (DONE) GO TO 590
C
C-------------------------------------------------------
C     THE NEXT BLOCK CONTAINS THE CALL TO THE
C     ONE-STEP INTEGRATOR DDASTP.
C     THIS IS A LOOPING POINT FOR THE INTEGRATION
C     STEPS.
C     CHECK FOR TOO MANY STEPS.
C     UPDATE WT.
C     CHECK FOR TOO MUCH ACCURACY REQUESTED.
C     COMPUTE MINIMUM STEPSIZE.
C-------------------------------------------------------
C
500   CONTINUE
C     CHECK FOR FAILURE TO COMPUTE INITIAL YPRIME
      IF (IDID .EQ. -12) GO TO 527
C
C     CHECK FOR TOO MANY STEPS
      IF((IWORK(LNST)-IWORK(LNSTL)).LT.500)
     *   GO TO 510
           IDID=-1
           GO TO 527
C
C     UPDATE WT
510   CALL DDAWTS(NEQ,INFO(2),RTOL,ATOL,RWORK(LPHI),
     *  RWORK(LWT),RPAR,IPAR)
      DO 520 I=1,NEQ
         IF(RWORK(I+LWT-1).GT.0.0D0)GO TO 520
           IDID=-3
           GO TO 527
520   CONTINUE
C
C     TEST FOR TOO MUCH ACCURACY REQUESTED.
      R=DDANRM(NEQ,RWORK(LPHI),RWORK(LWT),RPAR,IPAR)*
     *   100.0D0*UROUND
      IF(R.LE.1.0D0)GO TO 525
C     MULTIPLY RTOL AND ATOL BY R AND RETURN
      IF(INFO(2).EQ.1)GO TO 523
           RTOL(1)=R*RTOL(1)
           ATOL(1)=R*ATOL(1)
           IDID=-2
           GO TO 527
523   DO 524 I=1,NEQ
           RTOL(I)=R*RTOL(I)
524        ATOL(I)=R*ATOL(I)
      IDID=-2
      GO TO 527
525   CONTINUE
C
C     COMPUTE MINIMUM STEPSIZE
      HMIN=4.0D0*UROUND*DMAX1(DABS(TN),DABS(TOUT))
C
      CALL DDASTP(TN,Y,YPRIME,NEQ,
     *   RES,JAC,H,RWORK(LWT),INFO(1),IDID,RPAR,IPAR,
     *   RWORK(LPHI),RWORK(LDELTA),RWORK(LE),
     *   RWORK(LWM),IWORK(LIWM),
     *   RWORK(LALPHA),RWORK(LBETA),RWORK(LGAMMA),
     *   RWORK(LPSI),RWORK(LSIGMA),
     *   RWORK(LCJ),RWORK(LCJOLD),RWORK(LHOLD),
     *   RWORK(LS),HMIN,RWORK(LROUND),
     *   IWORK(LPHASE),IWORK(LJCALC),IWORK(LK),
     *   IWORK(LKOLD),IWORK(LNS),INFO(10))
527   IF(IDID.LT.0)GO TO 600
C
C------------------------------------------------------
C     THIS BLOCK HANDLES THE CASE OF A SUCCESSFUL
C     RETURN FROM DDASTP (IDID=1) TEST FOR
C     STOP CONDITIONS.
C--------------------------------------------------------
C
      IF(INFO(4).NE.0)GO TO 540
           IF(INFO(3).NE.0)GO TO 530
             IF((TN-TOUT)*H.LT.0.0D0)GO TO 500
             CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *         IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
             IDID=3
             T=TOUT
             GO TO 580
530          IF((TN-TOUT)*H.GE.0.0D0)GO TO 535
             T=TN
             IDID=1
             GO TO 580
535          CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *         IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
             IDID=3
             T=TOUT
             GO TO 580
540   IF(INFO(3).NE.0)GO TO 550
      IF((TN-TOUT)*H.LT.0.0D0)GO TO 542
         CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *     IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
         T=TOUT
         IDID=3
         GO TO 580
542   IF(DABS(TN-TSTOP).LE.100.0D0*UROUND*
     *   (DABS(TN)+DABS(H)))GO TO 545
      TNEXT=TN+H*(1.0D0+4.0D0*UROUND)
      IF((TNEXT-TSTOP)*H.LE.0.0D0)GO TO 500
      H=(TSTOP-TN)*(1.0D0-4.0D0*UROUND)
      GO TO 500
545   IDID=2
      T=TSTOP
      GO TO 580
550   IF((TN-TOUT)*H.GE.0.0D0)GO TO 555
      IF(DABS(TN-TSTOP).LE.100.0D0*UROUND*(DABS(TN)+DABS(H)))GO TO 552
      T=TN
      IDID=1
      GO TO 580
552   IDID=2
      T=TSTOP
      GO TO 580
555   CALL DDATRP(TN,TOUT,Y,YPRIME,NEQ,
     *   IWORK(LKOLD),RWORK(LPHI),RWORK(LPSI))
      T=TOUT
      IDID=3
580   CONTINUE
C
C--------------------------------------------------------
C     ALL SUCCESSFUL RETURNS FROM DASSL ARE MADE FROM
C     THIS BLOCK.
C--------------------------------------------------------
C
590   CONTINUE
      RWORK(LTN)=TN
      RWORK(LH)=H
      RETURN
C
C-----------------------------------------------------------------------
C     THIS BLOCK HANDLES ALL UNSUCCESSFUL
C     RETURNS OTHER THAN FOR ILLEGAL INPUT.
C-----------------------------------------------------------------------
C
600   CONTINUE
      ITEMP=-IDID
      GO TO (610,620,630,690,690,640,650,660,670,675,
     *  680,685), ITEMP
C
C     THE MAXIMUM NUMBER OF STEPS WAS TAKEN BEFORE
C     REACHING TOUT
610   CALL XERRWV(
     *'DASSL--  AT CURRENT T (=R1)  500 STEPS',
     *38,610,0,0,0,0,1,TN,0.0D0)
      CALL XERRWV('DASSL--  TAKEN ON THIS CALL BEFORE REACHING TOUT',
     *48,611,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     TOO MUCH ACCURACY FOR MACHINE PRECISION
620   CALL XERRWV(
     *'DASSL--  AT T (=R1) TOO MUCH ACCURACY REQUESTED',
     *47,620,0,0,0,0,1,TN,0.0D0)
      CALL XERRWV(
     *'DASSL--  FOR PRECISION OF MACHINE. RTOL AND ATOL',
     *48,621,0,0,0,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  WERE INCREASED TO APPROPRIATE VALUES',
     *45,622,0,0,0,0,0,0.0D0,0.0D0)
C
      GO TO 690
C     WT(I) .LE. 0.0D0 FOR SOME I (NOT AT START OF PROBLEM)
630   CALL XERRWV(
     *'DASSL--  AT T (=R1) SOME ELEMENT OF WT',
     *38,630,0,0,0,0,1,TN,0.0D0)
      CALL XERRWV('DASSL--  HAS BECOME .LE. 0.0',
     *28,631,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     ERROR TEST FAILED REPEATEDLY OR WITH H=HMIN
640   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,640,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  ERROR TEST FAILED REPEATEDLY OR WITH ABS(H)=HMIN',
     *57,641,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     CORRECTOR CONVERGENCE FAILED REPEATEDLY OR WITH H=HMIN
650   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,650,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  CORRECTOR FAILED TO CONVERGE REPEATEDLY',
     *48,651,0,0,0,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  OR WITH ABS(H)=HMIN',
     *28,652,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     THE ITERATION MATRIX IS SINGULAR
660   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,660,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  ITERATION MATRIX IS SINGULAR',
     *37,661,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     CORRECTOR FAILURE PRECEEDED BY ERROR TEST FAILURES.
670   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,670,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  CORRECTOR COULD NOT CONVERGE.  ALSO, THE',
     *49,671,0,0,0,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  ERROR TEST FAILED REPEATEDLY.',
     *38,672,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     CORRECTOR FAILURE BECAUSE IRES = -1
675   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,675,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  CORRECTOR COULD NOT CONVERGE BECAUSE',
     *455,676,0,0,0,0,0,0.0D0,0.0D0)
      CALL XERRWV(
     *'DASSL--  IRES WAS EQUAL TO MINUS ONE',
     *36,677,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     FAILURE BECAUSE IRES = -2
680   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2)',
     *40,680,0,0,0,0,2,TN,H)
      CALL XERRWV(
     *'DASSL--  IRES WAS EQUAL TO MINUS TWO',
     *36,681,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
C
C     FAILED TO COMPUTE INITIAL YPRIME
685   CALL XERRWV(
     *'DASSL--  AT T (=R1) AND STEPSIZE H (=R2) THE',
     *44,685,0,0,0,0,2,TN,HO)
      CALL XERRWV(
     *'DASSL--  INITIAL YPRIME COULD NOT BE COMPUTED',
     *45,686,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 690
690   CONTINUE
      INFO(1)=-1
      T=TN
      RWORK(LTN)=TN
      RWORK(LH)=H
      RETURN
C-----------------------------------------------------------------------
C     THIS BLOCK HANDLES ALL ERROR RETURNS DUE
C     TO ILLEGAL INPUT, AS DETECTED BEFORE CALLING
C     DDASTP. FIRST THE ERROR MESSAGE ROUTINE IS
C     CALLED. IF THIS HAPPENS TWICE IN
C     SUCCESSION, EXECUTION IS TERMINATED
C
C-----------------------------------------------------------------------
701   CALL XERRWV(
     *'DASSL--  SOME ELEMENT OF INFO VECTOR IS NOT ZERO OR ONE',
     *55,1,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
702   CALL XERRWV('DASSL--  NEQ (=I1) .LE. 0',
     *25,2,0,1,NEQ,0,0,0.0D0,0.0D0)
      GO TO 750
703   CALL XERRWV('DASSL--  MAXORD (=I1) NOT IN RANGE',
     *34,3,0,1,MXORD,0,0,0.0D0,0.0D0)
      GO TO 750
704   CALL XERRWV(
     *'DASSL--  RWORK LENGTH NEEDED, LENRW (=I1), EXCEEDS LRW (=I2)',
     *60,4,0,2,LENRW,LRW,0,0.0D0,0.0D0)
      GO TO 750
705   CALL XERRWV(
     *'DASSL--  IWORK LENGTH NEEDED, LENIW (=I1), EXCEEDS LIW (=I2)',
     *60,5,0,2,LENIW,LIW,0,0.0D0,0.0D0)
      GO TO 750
706   CALL XERRWV(
     *'DASSL--  SOME ELEMENT OF RTOL IS .LT. 0',
     *39,6,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
707   CALL XERRWV(
     *'DASSL--  SOME ELEMENT OF ATOL IS .LT. 0',
     *39,7,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
708   CALL XERRWV(
     *'DASSL--  ALL ELEMENTS OF RTOL AND ATOL ARE ZERO',
     *47,8,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
709   CALL XERRWV(
     *'DASSL--  INFO(4) = 1 AND TSTOP (=R1) BEHIND TOUT (=R2)',
     *54,9,0,0,0,0,2,TSTOP,TOUT)
      GO TO 750
710   CALL XERRWV('DASSL--  HMAX (=R1) .LT. 0.0',
     *28,10,0,0,0,0,1,HMAX,0.0D0)
      GO TO 750
711   CALL XERRWV('DASSL--  TOUT (=R1) BEHIND T (=R2)',
     *34,11,0,0,0,0,2,TOUT,T)
      GO TO 750
712   CALL XERRWV('DASSL--  INFO(8)=1 AND H0=0.0',
     *29,12,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
713   CALL XERRWV('DASSL--  SOME ELEMENT OF WT IS .LE. 0.0',
     *39,13,0,0,0,0,0,0.0D0,0.0D0)
      GO TO 750
714   CALL XERRWV(
     *'DASSL--  TOUT (=R1) TOO CLOSE TO T (=R2) TO START INTEGRATION',
     *61,14,0,0,0,0,2,TOUT,T)
      GO TO 750
715   CALL XERRWV(
     *'DASSL--  INFO(4)=1 AND TSTOP (=R1) BEHIND T (=R2)',
     *49,15,0,0,0,0,2,TSTOP,T)
      GO TO 750
717   CALL XERRWV(
     *'DASSL--  ML (=I1) ILLEGAL. EITHER .LT. 0 OR .GT. NEQ',
     *52,17,0,1,IWORK(LML),0,0,0.0D0,0.0D0)
      GO TO 750
718   CALL XERRWV(
     *'DASSL--  MU (=I1) ILLEGAL. EITHER .LT. 0 OR .GT. NEQ',
     *52,18,0,1,IWORK(LMU),0,0,0.0D0,0.0D0)
      GO TO 750
719   CALL XERRWV(
     *'DASSL--  TOUT (=R1) IS EQUAL TO T (=R2)',
     *39,19,0,0,0,0,2,TOUT,T)
      GO TO 750
750   IF(INFO(1).EQ.-1) GO TO 760
      INFO(1)=-1
      IDID=-33
      RETURN
760   CALL XERRWV(
     *'DASSL--  REPEATED OCCURRENCES OF ILLEGAL INPUT',
     *46,801,0,0,0,0,0,0.0D0,0.0D0)
770   CALL XERRWV(
     *'DASSL--  RUN TERMINATED. APPARENT INFINITE LOOP',
     *47,802,1,0,0,0,0,0.0D0,0.0D0)
      RETURN
C-----------END OF SUBROUTINE DASSL-------------------------------------
      END
      SUBROUTINE DDAWTS(NEQ,IWT,RTOL,ATOL,Y,WT,RPAR,IPAR)
C
C***BEGIN PROLOGUE  DDAWTS
C***REFER TO  DASSL
C***ROUTINES CALLED  (NONE)
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDAWTS
C-----------------------------------------------------------------------
C     THIS SUBROUTINE SETS THE ERROR WEIGHT VECTOR
C     WT ACCORDING TO WT(I)=RTOL(I)*ABS(Y(I))+ATOL(I),
C     I=1,-,N.
C     RTOL AND ATOL ARE SCALARS IF IWT = 0,
C     AND VECTORS IF IWT = 1.
C-----------------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION RTOL(NEQ),ATOL(NEQ),Y(NEQ),WT(NEQ)
      DIMENSION RPAR(*),IPAR(*)
      RTOLI=RTOL(1)
      ATOLI=ATOL(1)
      DO 20 I=1,NEQ
         IF (IWT .EQ.0) GO TO 10
           RTOLI=RTOL(I)
           ATOLI=ATOL(I)
10         WT(I)=RTOLI*DABS(Y(I))+ATOLI
20         CONTINUE
      RETURN
C-----------END OF SUBROUTINE DDAWTS-------------------------------------
      END
      SUBROUTINE DDASTP(X,Y,YPRIME,NEQ,
     *  RES,JAC,H,WT,JSTART,IDID,RPAR,IPAR,
     *  PHI,DELTA,E,WM,IWM,
     *  ALPHA,BETA,GAMMA,PSI,SIGMA,
     *  CJ,CJOLD,HOLD,S,HMIN,UROUND,
     *  IPHASE,JCALC,K,KOLD,NS,NONNEG)
C
C***BEGIN PROLOGUE  DDASTP
C***REFER TO  DASSL
C***ROUTINES CALLED  DDANRM,DDAJAC,DDASLV,DDATRP
C***COMMON BLOCKS    DDA001
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDASTP
C
C
C-----------------------------------------------------------------------
C     DASTEP SOLVES A SYSTEM OF DIFFERENTIAL/
C     ALGEBRAIC EQUATIONS OF THE FORM
C     G(X,Y,YPRIME) = 0,  FOR ONE STEP (NORMALLY
C     FROM X TO X+H).
C
C     THE METHODS USED ARE MODIFIED DIVIDED
C     DIFFERENCE,FIXED LEADING COEFFICIENT
C     FORMS OF BACKWARD DIFFERENTIATION
C     FORMULAS. THE CODE ADJUSTS THE STEPSIZE
C     AND ORDER TO CONTROL THE LOCAL ERROR PER
C     STEP.
C
C
C     THE PARAMETERS REPRESENT
C     X  --        INDEPENDENT VARIABLE
C     Y  --        SOLUTION VECTOR AT X
C     YPRIME --    DERIVATIVE OF SOLUTION VECTOR
C                  AFTER SUCCESSFUL STEP
C     NEQ --       NUMBER OF EQUATIONS TO BE INTEGRATED
C     RES --       EXTERNAL USER-SUPPLIED SUBROUTINE
C                  TO EVALUATE THE RESIDUAL.  THE CALL IS
C                  CALL RES(X,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
C                  X,Y,YPRIME ARE INPUT.  DELTA IS OUTPUT.
C                  ON INPUT, IRES=0.  RES SHOULD ALTER IRES ONLY
C                  IF IT ENCOUNTERS AN ILLEGAL VALUE OF Y OR A
C                  STOP CONDITION.  SET IRES=-1 IF AN INPUT VALUE
C                  OF Y IS ILLEGAL, AND DASTEP WILL TRY TO SOLVE
C                  THE PROBLEM WITHOUT GETTING IRES = -1.  IF
C                  IRES=-2, DASTEP RETURNS CONTROL TO THE CALLING
C                  PROGRAM WITH IDID = -11.
C     JAC --       EXTERNAL USER-SUPPLIED ROUTINE TO EVALUATE
C                  THE ITERATION MATRIX (THIS IS OPTIONAL)
C                  THE CALL IS OF THE FORM
C                  CALL JAC(X,Y,YPRIME,PD,CJ,RPAR,IPAR)
C                  PD IS THE MATRIX OF PARTIAL DERIVATIVES,
C                  PD=DG/DY+CJ*DG/DYPRIME
C     H --         APPROPRIATE STEP SIZE FOR NEXT STEP.
C                  NORMALLY DETERMINED BY THE CODE
C     WT --        VECTOR OF WEIGHTS FOR ERROR CRITERION.
C     JSTART --    INTEGER VARIABLE SET 0 FOR
C                  FIRST STEP, 1 OTHERWISE.
C     IDID --      COMPLETION CODE WITH THE FOLLOWING MEANINGS
C                  IDID= 1 -- THE STEP WAS COMPLETED SUCCESSFULLY
C                  IDID=-6 -- THE ERROR TEST FAILED REPEATEDLY
C                  IDID=-7 -- THE CORRECTOR COULD NOT CONVERGE
C                  IDID=-8 -- THE ITERATION MATRIX IS SINGULAR
C                  IDID=-9 -- THE CORRECTOR COULD NOT CONVERGE.
C                             THERE WERE REPEATED ERROR TEST
C                             FAILURES ON THIS STEP.
C                  IDID=-10-- THE CORRECTOR COULD NOT CONVERGE
C                             BECAUSE IRES WAS EQUAL TO MINUS ONE
C                  IDID=-11-- IRES EQUAL TO -2 WAS ENCOUNTERED,
C                             AND CONTROL IS BEING RETURNED TO
C                             THE CALLING PROGRAM
C     RPAR,IPAR -- REAL AND INTEGER PARAMETER ARRAYS THAT
C                  ARE USED FOR COMMUNICATION BETWEEN THE
C                  CALLING PROGRAM AND EXTERNAL USER ROUTINES
C                  THEY ARE NOT ALTERED BY DASTEP
C     PHI --       ARRAY OF DIVIDED DIFFERENCES USED BY
C                  DASTEP. THE LENGTH IS NEQ*(K+1),WHERE
C                  K IS THE MAXIMUM ORDER
C     DELTA,E --   WORK VECTORS FOR DASTEP OF LENGTH NEQ
C     WM,IWM --    REAL AND INTEGER ARRAYS STORING
C                  MATRIX INFORMATION SUCH AS THE MATRIX
C                  OF PARTIAL DERIVATIVES,PERMUTATION
C                  VECTOR,AND VARIOUS OTHER INFORMATION.
C
C     THE OTHER PARAMETERS ARE INFORMATION
C     WHICH IS NEEDED INTERNALLY BY DASTEP TO
C     CONTINUE FROM STEP TO STEP.
C
C-----------------------------------------------------------------------
C
C
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL CONVGD
      DIMENSION Y(NEQ),YPRIME(NEQ),WT(NEQ)
      DIMENSION PHI(NEQ,6),DELTA(NEQ),E(NEQ)
      DIMENSION WM(*),IWM(*)
      DIMENSION PSI(6),ALPHA(6),BETA(6),GAMMA(6),SIGMA(6)
      DIMENSION RPAR(*),IPAR(*)
      EXTERNAL RES,JAC
      COMMON/DDA001/NPD,NTEMP,
     *   LML,LMU,LMXORD,LMTYPE,
     *   LNST,LNRE,LNJE,LETF,LCTF,LIPVT
      DATA MAXIT/4/
      DATA XRATE/0.25D0/
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 1.
C     INITIALIZE. ON THE FIRST CALL,SET
C     THE ORDER TO 1 AND INITIALIZE
C     OTHER VARIABLES.
C-----------------------------------------------------------------------
C
C     INITIALIZATIONS FOR ALL CALLS
      IDID=1
      XOLD=X
      NCF=0
      NSF=0
      NEF=0
      IF(JSTART .NE. 0) GO TO 120
C
C     IF THIS IS THE FIRST STEP,PERFORM
C     OTHER INITIALIZATIONS
      IWM(LETF) = 0
      IWM(LCTF) = 0
      K=1
      KOLD=0
      HOLD=0.0D0
      JSTART=1
      PSI(1)=H
      CJOLD = 1.0D0/H
      CJ = CJOLD
      S = 100.D0
      JCALC = -1
      DELNRM=1.0D0
      IPHASE = 0
      NS=0
120   CONTINUE
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 2
C     COMPUTE COEFFICIENTS OF FORMULAS FOR
C     THIS STEP.
C-----------------------------------------------------------------------
200   CONTINUE
      KP1=K+1
      KP2=K+2
      KM1=K-1
      XOLD=X
      IF(H.NE.HOLD.OR.K .NE. KOLD) NS = 0
      NS=MIN0(NS+1,KOLD+2)
      NSP1=NS+1
      IF(KP1 .LT. NS)GO TO 230
C
      BETA(1)=1.0D0
      ALPHA(1)=1.0D0
      TEMP1=H
      GAMMA(1)=0.0D0
      SIGMA(1)=1.0D0
      DO 210 I=2,KP1
         TEMP2=PSI(I-1)
         PSI(I-1)=TEMP1
         BETA(I)=BETA(I-1)*PSI(I-1)/TEMP2
         TEMP1=TEMP2+H
         ALPHA(I)=H/TEMP1
         SIGMA(I)=DBLEI(I-1)*SIGMA(I-1)*ALPHA(I)
         GAMMA(I)=GAMMA(I-1)+ALPHA(I-1)/H
210      CONTINUE
      PSI(KP1)=TEMP1
230   CONTINUE
C
C     COMPUTE ALPHAS, ALPHA0
      ALPHAS = 0.0D0
      ALPHA0 = 0.0D0
      DO 240 I = 1,K
        ALPHAS = ALPHAS - 1.0D0/DBLEI(I)
        ALPHA0 = ALPHA0 - ALPHA(I)
240     CONTINUE
C
C     COMPUTE LEADING COEFFICIENT CJ
      CJLAST = CJ
      CJ = -ALPHAS/H
C
C     COMPUTE VARIABLE STEPSIZE ERROR COEFFICIENT CK
      CK = DABS(ALPHA(KP1) + ALPHAS - ALPHA0)
      CK = DMAX1(CK,ALPHA(KP1))
C
C     DECIDE WHETHER NEW JACOBIAN IS NEEDED
      TEMP1 = (1.0D0 - XRATE)/(1.0D0 + XRATE)
      TEMP2 = 1.0D0/TEMP1
      IF (CJ/CJOLD .LT. TEMP1 .OR. CJ/CJOLD .GT. TEMP2) JCALC = -1
      IF (CJ .NE. CJLAST) S = 100.D0
C
C     CHANGE PHI TO PHI STAR
      IF(KP1 .LT. NSP1) GO TO 280
      DO 270 J=NSP1,KP1
         DO 260 I=1,NEQ
260         PHI(I,J)=BETA(J)*PHI(I,J)
270      CONTINUE
280   CONTINUE
C
C     UPDATE TIME
      X=X+H
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 3
C     PREDICT THE SOLUTION AND DERIVATIVE,
C     AND SOLVE THE CORRECTOR EQUATION
C-----------------------------------------------------------------------
C
C     FIRST,PREDICT THE SOLUTION AND DERIVATIVE
300   CONTINUE
      DO 310 I=1,NEQ
         Y(I)=PHI(I,1)
310      YPRIME(I)=0.0D0
      DO 330 J=2,KP1
         DO 320 I=1,NEQ
            Y(I)=Y(I)+PHI(I,J)
320         YPRIME(I)=YPRIME(I)+GAMMA(J)*PHI(I,J)
330   CONTINUE
      PNORM = DDANRM (NEQ,Y,WT,RPAR,IPAR)
C
C
C
C     SOLVE THE CORRECTOR EQUATION USING A
C     MODIFIED NEWTON SCHEME.
      CONVGD= .TRUE.
      M=0
      IWM(LNRE)=IWM(LNRE)+1
      IRES = 0
      CALL RES(X,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
      IF (IRES .LT. 0) GO TO 380
C
C
C     IF INDICATED,REEVALUATE THE
C     ITERATION MATRIX PD = DG/DY + CJ*DG/DYPRIME
C     (WHERE G(X,Y,YPRIME)=0). SET
C     JCALC TO 0 AS AN INDICATOR THAT
C     THIS HAS BEEN DONE.
      IF(JCALC .NE. -1)GO TO 340
      IWM(LNJE)=IWM(LNJE)+1
      JCALC=0
      CALL DDAJAC(NEQ,X,Y,YPRIME,DELTA,CJ,H,
     * IER,WT,E,WM,IWM,RES,IRES,UROUND,JAC,RPAR,IPAR)
      CJOLD=CJ
      S = 100.D0
      IF (IRES .LT. 0) GO TO 380
      IF(IER .NE. 0)GO TO 380
      NSF=0
C
C
C     INITIALIZE THE ERROR ACCUMULATION VECTOR E.
340   CONTINUE
      DO 345 I=1,NEQ
345      E(I)=0.0D0
C
      S = 100.E0
C
C
C     CORRECTOR LOOP.
350   CONTINUE
C
C     MULTIPLY RESIDUAL BY TEMP1 TO ACCELERATE CONVERGENCE
      TEMP1 = 2.0D0/(1.0D0 + CJ/CJOLD)
      DO 355 I = 1,NEQ
355     DELTA(I) = DELTA(I) * TEMP1
C
C     COMPUTE A NEW ITERATE (BACK-SUBSTITUTION).
C     STORE THE CORRECTION IN DELTA.
      CALL DDASLV(NEQ,DELTA,WM,IWM)
C
C     UPDATE Y,E,AND YPRIME
      DO 360 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
         E(I)=E(I)-DELTA(I)
360      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)
C
C     TEST FOR CONVERGENCE OF THE ITERATION
      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF (DELNRM .LE. 100.D0*UROUND*PNORM) GO TO 375
      IF (M .GT. 0) GO TO 365
         OLDNRM = DELNRM
         GO TO 367
365   RATE = (DELNRM/OLDNRM)**(1.0D0/DBLEI(M))
      IF (RATE .GT. 0.90D0) GO TO 370
      S = RATE/(1.0D0 - RATE)
367   IF (S*DELNRM .LE. 0.33D0) GO TO 375
C
C     THE CORRECTOR HAS NOT YET CONVERGED.
C     UPDATE M AND TEST WHETHER THE
C     MAXIMUM NUMBER OF ITERATIONS HAVE
C     BEEN TRIED.
      M=M+1
      IF(M.GE.MAXIT)GO TO 370
C
C     EVALUATE THE RESIDUAL
C     AND GO BACK TO DO ANOTHER ITERATION
      IWM(LNRE)=IWM(LNRE)+1
      IRES = 0
      CALL RES(X,Y,YPRIME,DELTA,IRES,
     *  RPAR,IPAR)
      IF (IRES .LT. 0) GO TO 380
      GO TO 350
C
C
C     THE CORRECTOR FAILED TO CONVERGE IN MAXIT
C     ITERATIONS. IF THE ITERATION MATRIX
C     IS NOT CURRENT,RE-DO THE STEP WITH
C     A NEW ITERATION MATRIX.
370   CONTINUE
      IF(JCALC.EQ.0)GO TO 380
      JCALC=-1
      GO TO 300
C
C
C     THE ITERATION HAS CONVERGED.  IF NONNEGATIVITY OF SOLUTION IS
C     REQUIRED, SET THE SOLUTION NONNEGATIVE, IF THE PERTURBATION
C     TO DO IT IS SMALL ENOUGH.  IF THE CHANGE IS TOO LARGE, THEN
C     CONSIDER THE CORRECTOR ITERATION TO HAVE FAILED.
375   IF(NONNEG .EQ. 0) GO TO 390
      DO 377 I = 1,NEQ
377      DELTA(I) = DMIN1(Y(I),0.0D0)
      DELNRM = DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF(DELNRM .GT. 0.33D0) GO TO 380
      DO 378 I = 1,NEQ
378      E(I) = E(I) - DELTA(I)
      GO TO 390
C
C
C     EXITS FROM BLOCK 3
C     NO CONVERGENCE WITH CURRENT ITERATION
C     MATRIX,OR SINGULAR ITERATION MATRIX
380   CONVGD= .FALSE.
390   JCALC = 1
      IF(.NOT.CONVGD)GO TO 600
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 4
C     ESTIMATE THE ERRORS AT ORDERS K,K-1,K-2
C     AS IF CONSTANT STEPSIZE WAS USED. ESTIMATE
C     THE LOCAL ERROR AT ORDER K AND TEST
C     WHETHER THE CURRENT STEP IS SUCCESSFUL.
C-----------------------------------------------------------------------
C
C     ESTIMATE ERRORS AT ORDERS K,K-1,K-2
      ENORM = DDANRM(NEQ,E,WT,RPAR,IPAR)
      ERK = SIGMA(K+1)*ENORM
      TERK = FLOAT(K+1)*ERK
      EST = ERK
      KNEW=K
      IF(K .EQ. 1)GO TO 430
      DO 405 I = 1,NEQ
405     DELTA(I) = PHI(I,KP1) + E(I)
      ERKM1=SIGMA(K)*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKM1 = FLOAT(K)*ERKM1
      IF(K .GT. 2)GO TO 410
      IF(TERKM1 .LE. 0.5*TERK)GO TO 420
      GO TO 430
410   CONTINUE
      DO 415 I = 1,NEQ
415     DELTA(I) = PHI(I,K) + DELTA(I)
      ERKM2=SIGMA(K-1)*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKM2 = FLOAT(K-1)*ERKM2
      IF(DMAX1(TERKM1,TERKM2).GT.TERK)GO TO 430
C     LOWER THE ORDER
420   CONTINUE
      KNEW=K-1
      EST = ERKM1
C
C
C     CALCULATE THE LOCAL ERROR FOR THE CURRENT STEP
C     TO SEE IF THE STEP WAS SUCCESSFUL
430   CONTINUE
      ERR = CK * ENORM
      IF(ERR .GT. 1.0D0)GO TO 600
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 5
C     THE STEP IS SUCCESSFUL. DETERMINE
C     THE BEST ORDER AND STEPSIZE FOR
C     THE NEXT STEP. UPDATE THE DIFFERENCES
C     FOR THE NEXT STEP.
C-----------------------------------------------------------------------
      IDID=1
      IWM(LNST)=IWM(LNST)+1
      KDIFF=K-KOLD
      KOLD=K
      HOLD=H
C
C
C     ESTIMATE THE ERROR AT ORDER K+1 UNLESS
C        ALREADY DECIDED TO LOWER ORDER, OR
C        ALREADY USING MAXIMUM ORDER, OR
C        STEPSIZE NOT CONSTANT, OR
C        ORDER RAISED IN PREVIOUS STEP
      IF(KNEW.EQ.KM1.OR.K.EQ.IWM(LMXORD))IPHASE=1
      IF(IPHASE .EQ. 0)GO TO 545
      IF(KNEW.EQ.KM1)GO TO 540
      IF(K.EQ.IWM(LMXORD)) GO TO 550
      IF(KP1.GE.NS.OR.KDIFF.EQ.1)GO TO 550
      DO 510 I=1,NEQ
510      DELTA(I)=E(I)-PHI(I,KP2)
      ERKP1 = (1.0D0/DBLEI(K+2))*DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      TERKP1 = FLOAT(K+2)*ERKP1
      IF(K.GT.1)GO TO 520
      IF(TERKP1.GE.0.5D0*TERK)GO TO 550
      GO TO 530
520   IF(TERKM1.LE.DMIN1(TERK,TERKP1))GO TO 540
      IF(TERKP1.GE.TERK.OR.K.EQ.IWM(LMXORD))GO TO 550
C
C     RAISE ORDER
530   K=KP1
      EST = ERKP1
      GO TO 550
C
C     LOWER ORDER
540   K=KM1
      EST = ERKM1
      GO TO 550
C
C     IF IPHASE = 0, INCREASE ORDER BY ONE AND MULTIPLY STEPSIZE BY
C     FACTOR TWO
545   K = KP1
      HNEW = H*2.0D0
      H = HNEW
      GO TO 575
C
C
C     DETERMINE THE APPROPRIATE STEPSIZE FOR
C     THE NEXT STEP.
550   HNEW=H
      TEMP2=K+1
      R=(2.0D0*EST+0.0001D0)**(-1.0D0/TEMP2)
      IF(R .LT. 2.0D0) GO TO 555
      HNEW = 2.0D0*H
      GO TO 560
555   IF(R .GT. 1.0D0) GO TO 560
      R = DMAX1(0.5D0,DMIN1(0.9D0,R))
      HNEW = H*R
560   H=HNEW
C
C
C     UPDATE DIFFERENCES FOR NEXT STEP
575   CONTINUE
      IF(KOLD.EQ.IWM(LMXORD))GO TO 585
      DO 580 I=1,NEQ
580      PHI(I,KP2)=E(I)
585   CONTINUE
      DO 590 I=1,NEQ
590      PHI(I,KP1)=PHI(I,KP1)+E(I)
      DO 595 J1=2,KP1
         J=KP1-J1+1
         DO 595 I=1,NEQ
595      PHI(I,J)=PHI(I,J)+PHI(I,J+1)
      RETURN
C
C
C
C
C
C-----------------------------------------------------------------------
C     BLOCK 6
C     THE STEP IS UNSUCCESSFUL. RESTORE X,PSI,PHI
C     DETERMINE APPROPRIATE STEPSIZE FOR
C     CONTINUING THE INTEGRATION, OR EXIT WITH
C     AN ERROR FLAG IF THERE HAVE BEEN MANY
C     FAILURES.
C-----------------------------------------------------------------------
600   IPHASE = 1
C
C     RESTORE X,PHI,PSI
      X=XOLD
      IF(KP1.LT.NSP1)GO TO 630
      DO 620 J=NSP1,KP1
         TEMP1=1.0D0/BETA(J)
         DO 610 I=1,NEQ
610         PHI(I,J)=TEMP1*PHI(I,J)
620      CONTINUE
630   CONTINUE
      DO 640 I=2,KP1
640      PSI(I-1)=PSI(I)-H
C
C
C     TEST WHETHER FAILURE IS DUE TO CORRECTOR ITERATION
C     OR ERROR TEST
      IF(CONVGD)GO TO 660
      IWM(LCTF)=IWM(LCTF)+1
C
C
C     THE NEWTON ITERATION FAILED TO CONVERGE WITH
C     A CURRENT ITERATION MATRIX.  DETERMINE THE CAUSE
C     OF THE FAILURE AND TAKE APPROPRIATE ACTION.
      IF(IER.EQ.0)GO TO 650
C
C     THE ITERATION MATRIX IS SINGULAR. REDUCE
C     THE STEPSIZE BY A FACTOR OF 4. IF
C     THIS HAPPENS THREE TIMES IN A ROW ON
C     THE SAME STEP, RETURN WITH AN ERROR FLAG
      NSF=NSF+1
      R = 0.25D0
      H=H*R
      IF (NSF .LT. 3 .AND. DABS(H) .GE. HMIN) GO TO 690
      IDID=-8
      GO TO 675
C
C
C     THE NEWTON ITERATION FAILED TO CONVERGE FOR A REASON
C     OTHER THAN A SINGULAR ITERATION MATRIX.  IF IRES = -2, THEN
C     RETURN.  OTHERWISE, REDUCE THE STEPSIZE AND TRY AGAIN, UNLESS
C     TOO MANY FAILURES HAVE OCCURED.
650   CONTINUE
      IF (IRES .GT. -2) GO TO 655
      IDID = -11
      GO TO 675
655   NCF = NCF + 1
      R = 0.25D0
      H = H*R
      IF (NCF .LT. 10 .AND. DABS(H) .GE. HMIN) GO TO 690
      IDID = -7
      IF (IRES .LT. 0) IDID = -10
      IF (NEF .GE. 3) IDID = -9
      GO TO 675
C
C
C     THE NEWTON SCHEME CONVERGED,AND THE CAUSE
C     OF THE FAILURE WAS THE ERROR ESTIMATE
C     EXCEEDING THE TOLERANCE.
660   NEF=NEF+1
      IWM(LETF)=IWM(LETF)+1
      IF (NEF .GT. 1) GO TO 665
C
C     ON FIRST ERROR TEST FAILURE, KEEP CURRENT ORDER OR LOWER
C     ORDER BY ONE.  COMPUTE NEW STEPSIZE BASED ON DIFFERENCES
C     OF THE SOLUTION.
      K = KNEW
      TEMP2 = K + 1
      R = 0.90D0*(2.0D0*EST+0.0001D0)**(-1.0D0/TEMP2)
      R = DMAX1(0.25D0,DMIN1(0.9D0,R))
      H = H*R
      IF (DABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C     ON SECOND ERROR TEST FAILURE, USE THE CURRENT ORDER OR
C     DECREASE ORDER BY ONE.  REDUCE THE STEPSIZE BY A FACTOR OF
C     ONE QUARTER.
665   IF (NEF .GT. 2) GO TO 670
      K = KNEW
      H = 0.25D0*H
      IF (DABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C     ON THIRD AND SUBSEQUENT ERROR TEST FAILURES, SET THE ORDER TO
C     ONE AND REDUCE THE STEPSIZE BY A FACTOR OF ONE QUARTER
670   K = 1
      H = 0.25D0*H
      IF (DABS(H) .GE. HMIN) GO TO 690
      IDID = -6
      GO TO 675
C
C
C
C
C     FOR ALL CRASHES, RESTORE Y TO ITS LAST VALUE,
C     INTERPOLATE TO FIND YPRIME AT LAST X, AND RETURN
675   CONTINUE
      CALL DDATRP(X,X,Y,YPRIME,NEQ,K,PHI,PSI)
      RETURN
C
C
C     GO BACK AND TRY THIS STEP AGAIN
690   GO TO 200
C
C------END OF SUBROUTINE DASTEP------
      END
      SUBROUTINE DDASLV(NEQ,DELTA,WM,IWM)
C
C***BEGIN PROLOGUE  DDASLV
C***REFER TO  DASSL
C***ROUTINES CALLED DGESL,DGBSL
C***COMMON BLOCKS    DDA001
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDASLV
C-----------------------------------------------------------------------
C     THIS ROUTINE MANAGES THE SOLUTION OF THE LINEAR
C     SYSTEM ARISING IN THE NEWTON ITERATION.
C     MATRICES AND REAL TEMPORARY STORAGE AND
C     REAL INFORMATION ARE STORED IN THE ARRAY WM.
C     INTEGER MATRIX INFORMATION IS STORED IN
C     THE ARRAY IWM.
C     FOR A DENSE MATRIX, THE LINPACK ROUTINE
C     DGESL IS CALLED.
C     FOR A BANDED MATRIX,THE LINPACK ROUTINE
C     DGBSL IS CALLED.
C-----------------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION DELTA(NEQ),WM(*),IWM(*)
      COMMON/DDA001/NPD,NTEMP,LML,LMU,
     *  LMXORD,LMTYPE,
     *  LNST,LNRE,LNJE,LETF,LCTF,LIPVT
C
      MTYPE=IWM(LMTYPE)
      GO TO(100,100,300,400,400),MTYPE
C
C     DENSE MATRIX
100   CALL DGESL(WM(NPD),NEQ,NEQ,IWM(LIPVT),DELTA,0)
      RETURN
C
C     DUMMY SECTION FOR MTYPE=3
300   CONTINUE
      RETURN
C
C     BANDED MATRIX
400   MEBAND=2*IWM(LML)+IWM(LMU)+1
      CALL DGBSL(WM(NPD),MEBAND,NEQ,IWM(LML),
     *  IWM(LMU),IWM(LIPVT),DELTA,0)
      RETURN
C------END OF SUBROUTINE DDASLV------
      END
      SUBROUTINE DDAJAC(NEQ,X,Y,YPRIME,DELTA,CJ,H,
     *  IER,WT,E,WM,IWM,RES,IRES,UROUND,JAC,RPAR,IPAR)
C
C***BEGIN PROLOGUE  DDAJAC
C***REFER TO  DASSL
C***ROUTINES CALLED  DGEFA,DGBFA
C***COMMON BLOCKS    DDA001
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDAJAC
C-----------------------------------------------------------------------
C     THIS ROUTINE COMPUTES THE ITERATION MATRIX
C     PD=DG/DY+CJ*DG/DYPRIME (WHERE G(X,Y,YPRIME)=0).
C     HERE PD IS COMPUTED BY THE USER-SUPPLIED
C     ROUTINE JAC IF IWM(MTYPE) IS 1 OR 4, AND
C     IT IS COMPUTED BY NUMERICAL FINITE DIFFERENCING
C     IF IWM(MTYPE)IS 2 OR 5
C     THE PARAMETERS HAVE THE FOLLOWING MEANINGS.
C     Y        = ARRAY CONTAINING PREDICTED VALUES
C     YPRIME   = ARRAY CONTAINING PREDICTED DERIVATIVES
C     DELTA    = RESIDUAL EVALUATED AT (X,Y,YPRIME)
C                (USED ONLY IF IWM(MTYPE)=2 OR 5)
C     CJ       = SCALAR PARAMETER DEFINING ITERATION MATRIX
C     H        = CURRENT STEPSIZE IN INTEGRATION
C     IER      = VARIABLE WHICH IS .NE. 0
C                IF ITERATION MATRIX IS SINGULAR,
C                AND 0 OTHERWISE.
C     WT       = VECTOR OF WEIGHTS FOR COMPUTING NORMS
C     E        = WORK SPACE (TEMPORARY) OF LENGTH NEQ
C     WM       = REAL WORK SPACE FOR MATRICES. ON
C                OUTPUT IT CONTAINS THE LU DECOMPOSITION
C                OF THE ITERATION MATRIX.
C     IWM      = INTEGER WORK SPACE CONTAINING
C                MATRIX INFORMATION
C     RES      = NAME OF THE EXTERNAL USER-SUPPLIED ROUTINE
C                TO EVALUATE THE RESIDUAL FUNCTION G(X,Y,YPRIME)
C     IRES     = FLAG WHICH IS EQUAL TO ZERO IF NO ILLEGAL VALUES
C                IN RES, AND LESS THAN ZERO OTHERWISE.  (IF IRES
C                IS LESS THAN ZERO, THE MATRIX WAS NOT COMPLETED)
C                IN THIS CASE (IF IRES .LT. 0), THEN IER = 0.
C     UROUND   = THE UNIT ROUNDOFF ERROR OF THE MACHINE BEING USED.
C     JAC      = NAME OF THE EXTERNAL USER-SUPPLIED ROUTINE
C                TO EVALUATE THE ITERATION MATRIX (THIS ROUTINE
C                IS ONLY USED IF IWM(MTYPE) IS 1 OR 4)
C-----------------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      EXTERNAL RES,JAC
      DIMENSION Y(NEQ),YPRIME(NEQ),DELTA(NEQ),WT(NEQ),E(NEQ)
      DIMENSION WM(*),IWM(*),RPAR(*),IPAR(*)
      COMMON/DDA001/NPD,NTEMP,
     *  LML,LMU,LMXORD,LMTYPE,
     *  LNST,LNRE,LNJE,LETF,LCTF,LIPVT
C
      IER = 0
      NPDM1=NPD-1
      MTYPE=IWM(LMTYPE)
      GO TO (100,200,300,400,500),MTYPE
C
C
C     DENSE USER-SUPPLIED MATRIX
100   LENPD=NEQ*NEQ
      DO 110 I=1,LENPD
110      WM(NPDM1+I)=0.0D0
      CALL JAC(X,Y,YPRIME,WM(NPD),CJ,RPAR,IPAR)
      GO TO 230
C
C
C     DENSE FINITE-DIFFERENCE-GENERATED MATRIX
200   IRES=0
      NROW=NPDM1
      SQUR = DSQRT(UROUND)
      DO 210 I=1,NEQ
         DEL=SQUR*DMAX1(DABS(Y(I)),DABS(H*YPRIME(I)),
     *     DABS(WT(I)))
         DEL=DSIGN(DEL,H*YPRIME(I))
         DEL=(Y(I)+DEL)-Y(I)
         YSAVE=Y(I)
         YPSAVE=YPRIME(I)
         Y(I)=Y(I)+DEL
         YPRIME(I)=YPRIME(I)+CJ*DEL
         CALL RES(X,Y,YPRIME,E,IRES,RPAR,IPAR)
         IF (IRES .LT. 0) RETURN
         DELINV=1.0D0/DEL
         DO 220 L=1,NEQ
220      WM(NROW+L)=(E(L)-DELTA(L))*DELINV
      NROW=NROW+NEQ
      Y(I)=YSAVE
      YPRIME(I)=YPSAVE
210   CONTINUE
C
C
C     DO DENSE-MATRIX LU DECOMPOSITION ON PD
230      CALL DGEFA(WM(NPD),NEQ,NEQ,IWM(LIPVT),IER)
      RETURN
C
C
C     DUMMY SECTION FOR IWM(MTYPE)=3
300   RETURN
C
C
C     BANDED USER-SUPPLIED MATRIX
400   LENPD=(2*IWM(LML)+IWM(LMU)+1)*NEQ
      DO 410 I=1,LENPD
410      WM(NPDM1+I)=0.0D0
      CALL JAC(X,Y,YPRIME,WM(NPD),CJ,RPAR,IPAR)
      MEBAND=2*IWM(LML)+IWM(LMU)+1
      GO TO 550
C
C
C     BANDED FINITE-DIFFERENCE-GENERATED MATRIX
500   MBAND=IWM(LML)+IWM(LMU)+1
      MBA=MIN0(MBAND,NEQ)
      MEBAND=MBAND+IWM(LML)
      MEB1=MEBAND-1
      MSAVE=(NEQ/MBAND)+1
      ISAVE=NTEMP-1
      IPSAVE=ISAVE+MSAVE
      IRES=0
      SQUR=DSQRT(UROUND)
      DO 540 J=1,MBA
         DO 510 N=J,NEQ,MBAND
          K= (N-J)/MBAND + 1
          WM(ISAVE+K)=Y(N)
          WM(IPSAVE+K)=YPRIME(N)
          DEL=SQUR*DMAX1(DABS(Y(N)),DABS(H*YPRIME(N)),
     *      DABS(WT(N)))
          DEL=DSIGN(DEL,H*YPRIME(N))
          DEL=(Y(N)+DEL)-Y(N)
          Y(N)=Y(N)+DEL
510       YPRIME(N)=YPRIME(N)+CJ*DEL
      CALL RES(X,Y,YPRIME,E,IRES,RPAR,IPAR)
      IF (IRES .LT. 0) RETURN
      DO 530 N=J,NEQ,MBAND
          K= (N-J)/MBAND + 1
          Y(N)=WM(ISAVE+K)
          YPRIME(N)=WM(IPSAVE+K)
          DEL=SQUR*DMAX1(DABS(Y(N)),DABS(H*YPRIME(N)),
     *      DABS(WT(N)))
          DEL=DSIGN(DEL,H*YPRIME(N))
          DEL=(Y(N)+DEL)-Y(N)
          DELINV=1.0D0/DEL
          I1=MAX0(1,(N-IWM(LMU)))
          I2=MIN0(NEQ,(N+IWM(LML)))
          II=N*MEB1-IWM(LML)+NPDM1
          DO 520 I=I1,I2
520         WM(II+I)=(E(I)-DELTA(I))*DELINV
530      CONTINUE
540   CONTINUE
C
C
C     DO LU DECOMPOSITION OF BANDED PD
550   CALL DGBFA(WM(NPD),MEBAND,NEQ,
     *    IWM(LML),IWM(LMU),IWM(LIPVT),IER)
      RETURN
C------END OF SUBROUTINE DDAJAC------
      END
      SUBROUTINE DDATRP(X,XOUT,YOUT,YPOUT,NEQ,KOLD,PHI,PSI)
C
C***BEGIN PROLOGUE  DDATRP
C***REFER TO  DASSL
C***ROUTINES CALLED  (NONE)
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDATRP
C
C-----------------------------------------------------------------------
C     THE METHODS IN SUBROUTINE DASTEP USE POLYNOMIALS
C     TO APPROXIMATE THE SOLUTION. DDATRP APPROXIMATES THE
C     SOLUTION AND ITS DERIVATIVE AT TIME XOUT BY EVALUATING
C     ONE OF THESE POLYNOMIALS,AND ITS DERIVATIVE,THERE.
C     INFORMATION DEFINING THIS POLYNOMIAL IS PASSED FROM
C     DASTEP, SO DDATRP CANNOT BE USED ALONE.
C
C     THE PARAMETERS ARE
C     X     THE CURRENT TIME IN THE INTEGRATION.
C     XOUT  THE TIME AT WHICH THE SOLUTION IS DESIRED
C     YOUT  THE INTERPOLATED APPROXIMATION TO Y AT XOUT
C           (THIS IS OUTPUT)
C     YPOUT THE INTERPOLATED APPROXIMATION TO YPRIME AT XOUT
C           (THIS IS OUTPUT)
C     NEQ   NUMBER OF EQUATIONS
C     KOLD  ORDER USED ON LAST SUCCESSFUL STEP
C     PHI   ARRAY OF SCALED DIVIDED DIFFERENCES OF Y
C     PSI   ARRAY OF PAST STEPSIZE HISTORY
C-----------------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION YOUT(NEQ),YPOUT(NEQ)
      DIMENSION PHI(NEQ,6),PSI(6)
      KOLDP1=KOLD+1
      TEMP1=XOUT-X
      DO 10 I=1,NEQ
         YOUT(I)=PHI(I,1)
10       YPOUT(I)=0.0D0
      C=1.0D0
      D=0.0D0
      GAMMA=TEMP1/PSI(1)
      DO 30 J=2,KOLDP1
         D=D*GAMMA+C/PSI(J-1)
         C=C*GAMMA
         GAMMA=(TEMP1+PSI(J-1))/PSI(J)
         DO 20 I=1,NEQ
            YOUT(I)=YOUT(I)+C*PHI(I,J)
20          YPOUT(I)=YPOUT(I)+D*PHI(I,J)
30       CONTINUE
      RETURN
C
C------END OF SUBROUTINE DDATRP------
      END
      SUBROUTINE DDAINI(X,Y,YPRIME,NEQ,
     *   RES,JAC,H,WT,IDID,RPAR,IPAR,
     *   PHI,DELTA,E,WM,IWM,
     *   HMIN,UROUND,NONNEG)
C
C***BEGIN PROLOGUE  DDAINI
C***REFER TO  DASSL
C***ROUTINES CALLED  DDANRM,DDAJAC,DDASLV
C***COMMON BLOCKS    DDA001
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE DDAINI
C
C-------------------------------------------------------
C     DDAINI TAKES ONE STEP OF SIZE H OR SMALLER
C     WITH THE BACKWARD EULER METHOD, TO
C     FIND YPRIME AT THE INITIAL TIME X. A MODIFIED
C     DAMPED NEWTON ITERATION IS USED TO
C     SOLVE THE CORRECTOR ITERATION.
C
C     THE INITIAL GUESS YPRIME IS USED IN THE
C     PREDICTION, AND IN FORMING THE ITERATION
C     MATRIX, BUT IS NOT INVOLVED IN THE
C     ERROR TEST. THIS MAY HAVE TROUBLE
C     CONVERGING IF THE INITIAL GUESS IS NO
C     GOOD, OR IF G(XY,YPRIME) DEPENDS
C     NONLINEARLY ON YPRIME.
C
C     THE PARAMETERS REPRESENT:
C     X --         INDEPENDENT VARIABLE
C     Y --         SOLUTION VECTOR AT X
C     YPRIME --    DERIVATIVE OF SOLUTION VECTOR
C     NEQ --       NUMBER OF EQUATIONS
C     H --         STEPSIZE. IMDER MAY USE A STEPSIZE
C                  SMALLER THAN H.
C     WT --        VECTOR OF WEIGHTS FOR ERROR
C                  CRITERION
C     IDID --      COMPLETION CODE WITH THE FOLLOWING MEANINGS
C                  IDID= 1 -- YPRIME WAS FOUND SUCCESSFULLY
C                  IDID=-12 -- DDAINI FAILED TO FIND YPRIME
C     RPAR,IPAR -- REAL AND INTEGER PARAMETER ARRAYS
C                  THAT ARE NOT ALTERED BY DDAINI
C     PHI --       WORK SPACE FOR DDAINI
C     DELTA,E --   WORK SPACE FOR DDAINI
C     WM,IWM --    REAL AND INTEGER ARRAYS STORING
C                  MATRIX INFORMATION
C
C-----------------------------------------------------------------
C
C

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL CONVGD
      DIMENSION Y(NEQ),YPRIME(NEQ),WT(NEQ)
      DIMENSION PHI(NEQ,6),DELTA(NEQ),E(NEQ)
      DIMENSION WM(*),IWM(*)
      DIMENSION RPAR(*),IPAR(*)
      EXTERNAL RES,JAC
      COMMON/DDA001/NPD,NTEMP,
     *  LML,LMU,LMXORD,LMTYPE,
     *  LNST,LNRE,LNJE,LETF,LCTF,LIPVT

      DATA MAXIT/10/,MJAC/5/
      DATA DAMP/0.75D0/

C
C
C---------------------------------------------------
C     BLOCK 1.
C     INITIALIZATIONS.
C---------------------------------------------------
C
      IDID=1
      NEF=0
      NCF=0
      NSF=0
      YNORM=DDANRM(NEQ,Y,WT,RPAR,IPAR)
C
C     SAVE Y AND YPRIME IN PHI
      DO 100 I=1,NEQ
         PHI(I,1)=Y(I)
100      PHI(I,2)=YPRIME(I)

C
C
C----------------------------------------------------
C     BLOCK 2.
C     DO ONE BACKWARD EULER STEP.
C----------------------------------------------------
C
C     SET UP FOR START OF CORRECTOR ITERATION
200   CJ=1.0D0/H
      XNEW=X+H
C
C     PREDICT SOLUTION AND DERIVATIVE

      DO 250 I=1,NEQ
250     Y(I)=Y(I)+H*YPRIME(I)
C
      JCALC=-1
      M=0
      CONVGD=.TRUE.
C
C
C     CORRECTOR LOOP.
300   IWM(LNRE)=IWM(LNRE)+1
      IRES=0

      CALL RES(XNEW,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
      IF (IRES.LT.0) GO TO 430
C
C
C     EVALUATE THE ITERATION MATRIX
      IF (JCALC.NE.-1) GO TO 310
      IWM(LNJE)=IWM(LNJE)+1
      JCALC=0
      CALL DDAJAC(NEQ,XNEW,Y,YPRIME,DELTA,CJ,H,
     *   IER,WT,E,WM,IWM,RES,IRES,
     *   UROUND,JAC,RPAR,IPAR)

      S=1000000.D0
      IF (IRES.LT.0) GO TO 430
      IF (IER.NE.0) GO TO 430
      NSF=0

C
C
C
C     MULTIPLY RESIDUAL BY DAMPING FACTOR
310   CONTINUE
      DO 320 I=1,NEQ
320      DELTA(I)=DELTA(I)*DAMP

C
C     COMPUTE A NEW ITERATE (BACK SUBSTITUTION)
C     STORE THE CORRECTION IN DELTA

      CALL DDASLV(NEQ,DELTA,WM,IWM)

C
C     UPDATE Y AND YPRIME

      DO 330 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
330      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)

C
C     TEST FOR CONVERGENCE OF THE ITERATION.

      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF (DELNRM.LE.100.D0*UROUND*YNORM)
     *   GO TO 400

      IF (M.GT.0) GO TO 340
         OLDNRM=DELNRM
         GO TO 350

340   RATE=(DELNRM/OLDNRM)**(1.0D0/DBLEI(M))
      IF (RATE.GT.0.90D0) GO TO 430
      S=RATE/(1.0D0-RATE)

350   IF (S*DELNRM .LE. 0.33D0) GO TO 400
C
C
C     THE CORRECTOR HAS NOT YET CONVERGED. UPDATE
C     M AND AND TEST WHETHER THE MAXIMUM
C     NUMBER OF ITERATIONS HAVE BEEN TRIED.
C     EVERY MJAC ITERATIONS, GET A NEW
C     ITERATION MATRIX.

      M=M+1
      IF (M.GE.MAXIT) GO TO 430

      IF ((M/MJAC)*MJAC.EQ.M) JCALC=-1

      GO TO 300

C
C
C     THE ITERATION HAS CONVERGED.
C     CHECK NONNEGATIVITY CONSTRAINTS
400   IF (NONNEG.EQ.0) GO TO 450
      DO 410 I=1,NEQ
410      DELTA(I)=DMIN1(Y(I),0.0D0)

      DELNRM=DDANRM(NEQ,DELTA,WT,RPAR,IPAR)
      IF (DELNRM.GT.0.33D0) GO TO 430

      DO 420 I=1,NEQ
         Y(I)=Y(I)-DELTA(I)
420      YPRIME(I)=YPRIME(I)-CJ*DELTA(I)
      GO TO 450
C
C
C     EXITS FROM CORRECTOR LOOP.
430   CONVGD=.FALSE.
450   IF (.NOT.CONVGD) GO TO 600
C
C
C
C-----------------------------------------------------
C     BLOCK 3.
C     THE CORRECTOR ITERATION CONVERGED.
C     DO ERROR TEST.
C-----------------------------------------------------
C

      DO 510 I=1,NEQ
510      E(I)=Y(I)-PHI(I,1)

      ERR=DDANRM(NEQ,E,WT,RPAR,IPAR)

      IF (ERR.LE.1.0D0) RETURN

C
C
C
C--------------------------------------------------------
C     BLOCK 4.
C     THE BACKWARD EULER STEP FAILED. RESTORE Y
C     AND YPRIME TO THEIR ORIGINAL VALUES.
C     REDUCE STEPSIZE AND TRY AGAIN, IF
C     POSSIBLE.
C---------------------------------------------------------
C

600   CONTINUE
      DO 610 I=1,NEQ
         Y(I)=PHI(I,1)
610      YPRIME(I)=PHI(I,2)

      IF (CONVGD) GO TO 640
      IF (IER.EQ.0) GO TO 620
         NSF=NSF+1
         H=H*0.25D0
         IF (NSF.LT.3.AND.DABS(H).GE.HMIN) GO TO 690
         IDID=-12
         RETURN
620   IF (IRES.GT.-2) GO TO 630
         IDID=-12
         RETURN
630   NCF=NCF+1
      H=H*0.25D0
      IF (NCF.LT.10.AND.DABS(H).GE.HMIN) GO TO 690
         IDID=-12
         RETURN

640   NEF=NEF+1
      R=0.90D0/(2.0D0*ERR+0.0001D0)
      R=DMAX1(0.1D0,DMIN1(0.5D0,R))
      H=H*R
      IF (DABS(H).GE.HMIN.AND.NEF.LT.10) GO TO 690
         IDID=-12
         RETURN
690      GO TO 200

C-------------END OF SUBROUTINE DDAINI----------------------
      END
      DOUBLE PRECISION FUNCTION DDANRM(NEQ,V,WT,RPAR,IPAR)
C
C***BEGIN PROLOGUE  DDANRM
C***REFER TO  DASSL
C***ROUTINES CALLED  (NONE)
C***DATE WRITTEN   830315   (YYMMDD)
C***REVISION DATE  830315   (YYMMDD)
C***END PROLOGUE  DDANRM
C-----------------------------------------------------------------------
C     THIS FUNCTION ROUTINE COMPUTES THE WEIGHTED
C     ROOT-MEAN-SQUARE NORM OF THE VECTOR OF LENGTH
C     NEQ CONTAINED IN THE ARRAY V,WITH WEIGHTS
C     CONTAINED IN THE ARRAY WT OF LENGTH NEQ.
C        DDANRM=SQRT((1/NEQ)*SUM(V(I)/WT(I))**2)
C-----------------------------------------------------------------------
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION V(NEQ),WT(NEQ)
      DIMENSION RPAR(*),IPAR(*)
      DDANRM = 0.0D0
      VMAX = 0.0D0
      DO 10 I = 1,NEQ
10      IF(DABS(V(I)/WT(I)) .GT. VMAX) VMAX = DABS(V(I)/WT(I))
      IF(VMAX .LE. 0.0D0) GO TO 30
      SUM = 0.0D0
      DO 20 I = 1,NEQ
20      SUM = SUM + ((V(I)/WT(I))/VMAX)**2
      DDANRM = VMAX*DSQRT(SUM/DBLEI(NEQ))
30    CONTINUE
      RETURN
C------END OF FUNCTION DDANRM------
      END
      SUBROUTINE DGEFA(A,LDA,N,IPVT,INFO)
      INTEGER LDA,N,IPVT(N),INFO
      DOUBLE PRECISION A(LDA,N)
C
C     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.
C
C     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .
C
C     ON ENTRY
C
C        A       DOUBLE PRECISION(LDA, N)
C                THE MATRIX TO BE FACTORED.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  A .
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX  A .
C
C     ON RETURN
C
C        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
C                WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO
C                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION T
      INTEGER IDAMAX,J,K,KP1,L,NM1
C
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      INFO = 0
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 70
      DO 60 K = 1, NM1
         KP1 = K + 1
C
C        FIND L = PIVOT INDEX
C
         L = IDAMAX(N-K+1,A(K,K),1) + K - 1
         IPVT(K) = L
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (A(L,K) .EQ. 0.0D0) GO TO 40
C
C           INTERCHANGE IF NECESSARY
C
            IF (L .EQ. K) GO TO 10
               T = A(L,K)
               A(L,K) = A(K,K)
               A(K,K) = T
   10       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T = -1.0D0/A(K,K)
            CALL DSCAL(N-K,T,A(K+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            DO 30 J = KP1, N
               T = A(L,J)
               IF (L .EQ. K) GO TO 20
                  A(L,J) = A(K,J)
                  A(K,J) = T
   20          CONTINUE
               CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)
   30       CONTINUE
         GO TO 50
   40    CONTINUE
            INFO = K
   50    CONTINUE
   60 CONTINUE
   70 CONTINUE
      IPVT(N) = N
      IF (A(N,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
      SUBROUTINE DGESL(A,LDA,N,IPVT,B,JOB)
      INTEGER LDA,N,IPVT(N),JOB
      DOUBLE PRECISION A(LDA,N),B(N)
C
C     DGESL SOLVES THE DOUBLE PRECISION SYSTEM
C     A * X = B  OR  TRANS(A) * X = B
C     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.
C
C     ON ENTRY
C
C        A       DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DGECO OR DGEFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  A .
C
C        N       INTEGER
C                THE ORDER OF THE MATRIX  A .
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGECO OR DGEFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C                = 0         TO SOLVE  A*X = B ,
C                = NONZERO   TO SOLVE  TRANS(A)*X = B  WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGECO HAS SET RCOND .GT. 0.0
C        OR DGEFA HAS SET INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGECO(A,LDA,N,IPVT,RCOND,Z)
C           IF (RCOND IS TOO SMALL) GO TO ...
C           DO 10 J = 1, P
C              CALL DGESL(A,LDA,N,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB,L,NM1
C
      NM1 = N - 1
      IF (JOB .NE. 0) GO TO 50
C
C        JOB = 0 , SOLVE  A * X = B
C        FIRST SOLVE  L*Y = B
C
         IF (NM1 .LT. 1) GO TO 30
         DO 20 K = 1, NM1
            L = IPVT(K)
            T = B(L)
            IF (L .EQ. K) GO TO 10
               B(L) = B(K)
               B(K) = T
   10       CONTINUE
            CALL DAXPY(N-K,T,A(K+1,K),1,B(K+1),1)
   20    CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X = Y
C
         DO 40 KB = 1, N
            K = N + 1 - KB
            B(K) = B(K)/A(K,K)
            T = -B(K)
            CALL DAXPY(K-1,T,A(1,K),1,B(1),1)
   40    CONTINUE
      GO TO 100
   50 CONTINUE
C
C        JOB = NONZERO, SOLVE  TRANS(A) * X = B
C        FIRST SOLVE  TRANS(U)*Y = B
C
         DO 60 K = 1, N
            T = DDOT(K-1,A(1,K),1,B(1),1)
            B(K) = (B(K) - T)/A(K,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X = Y
C
         IF (NM1 .LT. 1) GO TO 90
         DO 80 KB = 1, NM1
            K = N - KB
            B(K) = B(K) + DDOT(N-K,A(K+1,K),1,B(K+1),1)
            L = IPVT(K)
            IF (L .EQ. K) GO TO 70
               T = B(L)
               B(L) = B(K)
               B(K) = T
   70       CONTINUE
   80    CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DGBFA(ABD,LDA,N,ML,MU,IPVT,INFO)
      INTEGER LDA,N,ML,MU,IPVT(N),INFO
      DOUBLE PRECISION ABD(LDA,N)
C
C     DGBFA FACTORS A DOUBLE PRECISION BAND MATRIX BY ELIMINATION.
C
C     DGBFA IS USUALLY CALLED BY DGBCO, BUT IT CAN BE CALLED
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                CONTAINS THE MATRIX IN BAND STORAGE.  THE COLUMNS
C                OF THE MATRIX ARE STORED IN THE COLUMNS OF  ABD  AND
C                THE DIAGONALS OF THE MATRIX ARE STORED IN ROWS
C                ML+1 THROUGH 2*ML+MU+1 OF  ABD .
C                SEE THE COMMENTS BELOW FOR DETAILS.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C                LDA MUST BE .GE. 2*ML + MU + 1 .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C                0 .LE. ML .LT. N .
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C                0 .LE. MU .LT. N .
C                MORE EFFICIENT IF  ML .LE. MU .
C     ON RETURN
C
C        ABD     AN UPPER TRIANGULAR MATRIX IN BAND STORAGE AND
C                THE MULTIPLIERS WHICH WERE USED TO OBTAIN IT.
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
C
C        IPVT    INTEGER(N)
C                AN INTEGER VECTOR OF PIVOT INDICES.
C
C        INFO    INTEGER
C                = 0  NORMAL VALUE.
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES
C                     INDICATE THAT DGBSL WILL DIVIDE BY ZERO IF
C                     CALLED.  USE  RCOND  IN DGBCO FOR A RELIABLE
C                     INDICATION OF SINGULARITY.
C
C     BAND STORAGE
C
C           IF  A  IS A BAND MATRIX, THE FOLLOWING PROGRAM SEGMENT
C           WILL SET UP THE INPUT.
C
C                   ML = (BAND WIDTH BELOW THE DIAGONAL)
C                   MU = (BAND WIDTH ABOVE THE DIAGONAL)
C                   M = ML + MU + 1
C                   DO 20 J = 1, N
C                      I1 = MAX0(1, J-MU)
C                      I2 = MIN0(N, J+ML)
C                      DO 10 I = I1, I2
C                         K = I - J + M
C                         ABD(K,J) = A(I,J)
C                10    CONTINUE
C                20 CONTINUE
C
C           THIS USES ROWS  ML+1  THROUGH  2*ML+MU+1  OF  ABD .
C           IN ADDITION, THE FIRST  ML  ROWS IN  ABD  ARE USED FOR
C           ELEMENTS GENERATED DURING THE TRIANGULARIZATION.
C           THE TOTAL NUMBER OF ROWS NEEDED IN  ABD  IS  2*ML+MU+1 .
C           THE  ML+MU BY ML+MU  UPPER LEFT TRIANGLE AND THE
C           ML BY ML  LOWER RIGHT TRIANGLE ARE NOT REFERENCED.
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DSCAL,IDAMAX
C     FORTRAN MAX0,MIN0
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION T
      INTEGER I,IDAMAX,I0,J,JU,JZ,J0,J1,K,KP1,L,LM,M,MM,NM1
C
C
      M = ML + MU + 1
      INFO = 0
C
C     ZERO INITIAL FILL-IN COLUMNS
C
      J0 = MU + 2
      J1 = MIN0(N,M) - 1
      IF (J1 .LT. J0) GO TO 30
      DO 20 JZ = J0, J1
         I0 = M + 1 - JZ
         DO 10 I = I0, ML
            ABD(I,JZ) = 0.0D0
   10    CONTINUE
   20 CONTINUE
   30 CONTINUE
      JZ = J1
      JU = 0
C
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
C
      NM1 = N - 1
      IF (NM1 .LT. 1) GO TO 130
      DO 120 K = 1, NM1
         KP1 = K + 1
C
C        ZERO NEXT FILL-IN COLUMN
C
         JZ = JZ + 1
         IF (JZ .GT. N) GO TO 50
         IF (ML .LT. 1) GO TO 50
            DO 40 I = 1, ML
               ABD(I,JZ) = 0.0D0
   40       CONTINUE
   50    CONTINUE
C
C        FIND L = PIVOT INDEX
C
         LM = MIN0(ML,N-K)
         L = IDAMAX(LM+1,ABD(M,K),1) + M - 1
         IPVT(K) = L + K - M
C
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
C
         IF (ABD(L,K) .EQ. 0.0D0) GO TO 100
C
C           INTERCHANGE IF NECESSARY
C
            IF (L .EQ. M) GO TO 60
               T = ABD(L,K)
               ABD(L,K) = ABD(M,K)
               ABD(M,K) = T
   60       CONTINUE
C
C           COMPUTE MULTIPLIERS
C
            T = -1.0D0/ABD(M,K)
            CALL DSCAL(LM,T,ABD(M+1,K),1)
C
C           ROW ELIMINATION WITH COLUMN INDEXING
C
            JU = MIN0(MAX0(JU,MU+IPVT(K)),N)
            MM = M
            IF (JU .LT. KP1) GO TO 90
            DO 80 J = KP1, JU
               L = L - 1
               MM = MM - 1
               T = ABD(L,J)
               IF (L .EQ. MM) GO TO 70
                  ABD(L,J) = ABD(MM,J)
                  ABD(MM,J) = T
   70          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,ABD(MM+1,J),1)
   80       CONTINUE
   90       CONTINUE
         GO TO 110
  100    CONTINUE
            INFO = K
  110    CONTINUE
  120 CONTINUE
  130 CONTINUE
      IPVT(N) = N
      IF (ABD(M,N) .EQ. 0.0D0) INFO = N
      RETURN
      END
      SUBROUTINE DGBSL(ABD,LDA,N,ML,MU,IPVT,B,JOB)
      INTEGER LDA,N,ML,MU,IPVT(N),JOB
      DOUBLE PRECISION ABD(LDA,N),B(N)
C
C     DGBSL SOLVES THE DOUBLE PRECISION BAND SYSTEM
C     A * X = B  OR  TRANS(A) * X = B
C     USING THE FACTORS COMPUTED BY DGBCO OR DGBFA.
C
C     ON ENTRY
C
C        ABD     DOUBLE PRECISION(LDA, N)
C                THE OUTPUT FROM DGBCO OR DGBFA.
C
C        LDA     INTEGER
C                THE LEADING DIMENSION OF THE ARRAY  ABD .
C
C        N       INTEGER
C                THE ORDER OF THE ORIGINAL MATRIX.
C
C        ML      INTEGER
C                NUMBER OF DIAGONALS BELOW THE MAIN DIAGONAL.
C
C        MU      INTEGER
C                NUMBER OF DIAGONALS ABOVE THE MAIN DIAGONAL.
C
C        IPVT    INTEGER(N)
C                THE PIVOT VECTOR FROM DGBCO OR DGBFA.
C
C        B       DOUBLE PRECISION(N)
C                THE RIGHT HAND SIDE VECTOR.
C
C        JOB     INTEGER
C                = 0         TO SOLVE  A*X = B ,
C                = NONZERO   TO SOLVE  TRANS(A)*X = B , WHERE
C                            TRANS(A)  IS THE TRANSPOSE.
C
C     ON RETURN
C
C        B       THE SOLUTION VECTOR  X .
C
C     ERROR CONDITION
C
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
C        ZERO ON THE DIAGONAL.  TECHNICALLY THIS INDICATES SINGULARITY
C        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
C        SETTING OF LDA .  IT WILL NOT OCCUR IF THE SUBROUTINES ARE
C        CALLED CORRECTLY AND IF DGBCO HAS SET RCOND .GT. 0.0
C        OR DGBFA HAS SET INFO .EQ. 0 .
C
C     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
C     WITH  P  COLUMNS
C           CALL DGBCO(ABD,LDA,N,ML,MU,IPVT,RCOND,Z)
C           IF (RCOND IS TOO SMALL) GO TO ...
C           DO 10 J = 1, P
C              CALL DGBSL(ABD,LDA,N,ML,MU,IPVT,C(1,J),0)
C        10 CONTINUE
C
C     LINPACK. THIS VERSION DATED 08/14/78 .
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
C
C     SUBROUTINES AND FUNCTIONS
C
C     BLAS DAXPY,DDOT
C     FORTRAN MIN0
C
C     INTERNAL VARIABLES
C
      DOUBLE PRECISION DDOT,T
      INTEGER K,KB,L,LA,LB,LM,M,NM1
C
      M = MU + ML + 1
      NM1 = N - 1
      IF (JOB .NE. 0) GO TO 50
C
C        JOB = 0 , SOLVE  A * X = B
C        FIRST SOLVE L*Y = B
C
         IF (ML .EQ. 0) GO TO 30
         IF (NM1 .LT. 1) GO TO 30
            DO 20 K = 1, NM1
               LM = MIN0(ML,N-K)
               L = IPVT(K)
               T = B(L)
               IF (L .EQ. K) GO TO 10
                  B(L) = B(K)
                  B(K) = T
   10          CONTINUE
               CALL DAXPY(LM,T,ABD(M+1,K),1,B(K+1),1)
   20       CONTINUE
   30    CONTINUE
C
C        NOW SOLVE  U*X = Y
C
         DO 40 KB = 1, N
            K = N + 1 - KB
            B(K) = B(K)/ABD(M,K)
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = -B(K)
            CALL DAXPY(LM,T,ABD(LA,K),1,B(LB),1)
   40    CONTINUE
      GO TO 100
   50 CONTINUE
C
C        JOB = NONZERO, SOLVE  TRANS(A) * X = B
C        FIRST SOLVE  TRANS(U)*Y = B
C
         DO 60 K = 1, N
            LM = MIN0(K,M) - 1
            LA = M - LM
            LB = K - LM
            T = DDOT(LM,ABD(LA,K),1,B(LB),1)
            B(K) = (B(K) - T)/ABD(M,K)
   60    CONTINUE
C
C        NOW SOLVE TRANS(L)*X = Y
C
         IF (ML .EQ. 0) GO TO 90
         IF (NM1 .LT. 1) GO TO 90
            DO 80 KB = 1, NM1
               K = N - KB
               LM = MIN0(ML,N-K)
               B(K) = B(K) + DDOT(LM,ABD(M+1,K),1,B(K+1),1)
               L = IPVT(K)
               IF (L .EQ. K) GO TO 70
                  T = B(L)
                  B(L) = B(K)
                  B(K) = T
   70          CONTINUE
   80       CONTINUE
   90    CONTINUE
  100 CONTINUE
      RETURN
      END
      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)
C
C     CONSTANT TIMES A VECTOR PLUS A VECTOR.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(*),DY(*),DA
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      IF(N.LE.0)RETURN
      IF (DA .EQ. 0.0D0) RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DY(IY) = DY(IY) + DA*DX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DY(I) = DY(I) + DA*DX(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        DY(I) = DY(I) + DA*DX(I)
        DY(I + 1) = DY(I + 1) + DA*DX(I + 1)
        DY(I + 2) = DY(I + 2) + DA*DX(I + 2)
        DY(I + 3) = DY(I + 3) + DA*DX(I + 3)
   50 CONTINUE
      RETURN
      END
      SUBROUTINE DSCAL(N,DA,DX,INCX)
C
C     SCALES A VECTOR BY A CONSTANT.
C     USES UNROLLED LOOPS FOR INCREMENT EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DA,DX(N)
      INTEGER I,INCX,M,MP1,N,NINCX
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      NINCX = N*INCX
      DO 10 I = 1,NINCX,INCX
        DX(I) = DA*DX(I)
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DX(I) = DA*DX(I)
   30 CONTINUE
      IF( N .LT. 5 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DX(I) = DA*DX(I)
        DX(I + 1) = DA*DX(I + 1)
        DX(I + 2) = DA*DX(I + 2)
        DX(I + 3) = DA*DX(I + 3)
        DX(I + 4) = DA*DX(I + 4)
   50 CONTINUE
      RETURN
      END
      DOUBLE PRECISION FUNCTION DDOT(N,DX,INCX,DY,INCY)
C
C     FORMS THE DOT PRODUCT OF TWO VECTORS.
C     USES UNROLLED LOOPS FOR INCREMENTS EQUAL TO ONE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(N),DY(N),DTEMP
      INTEGER I,INCX,INCY,IX,IY,M,MP1,N
C
      DDOT = 0.0D0
      DTEMP = 0.0D0
      IF(N.LE.0)RETURN
      IF(INCX.EQ.1.AND.INCY.EQ.1)GO TO 20
C
C        CODE FOR UNEQUAL INCREMENTS OR EQUAL INCREMENTS
C          NOT EQUAL TO 1
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        DTEMP = DTEMP + DX(IX)*DY(IY)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      DDOT = DTEMP
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP
C
   20 M = MOD(N,5)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        DTEMP = DTEMP + DX(I)*DY(I)
   30 CONTINUE
      IF( N .LT. 5 ) GO TO 60
   40 MP1 = M + 1
      DO 50 I = MP1,N,5
        DTEMP = DTEMP + DX(I)*DY(I) + DX(I + 1)*DY(I + 1) +
     *   DX(I + 2)*DY(I + 2) + DX(I + 3)*DY(I + 3) + DX(I + 4)*DY(I + 4)
   50 CONTINUE
   60 DDOT = DTEMP
      RETURN
      END
      INTEGER FUNCTION IDAMAX(N,DX,INCX)
C
C     FINDS THE INDEX OF ELEMENT HAVING MAX. ABSOLUTE VALUE.
C     JACK DONGARRA, LINPACK, 3/11/78.
C
      DOUBLE PRECISION DX(N),DMAX
      INTEGER I,INCX,IX,N
C
      IDAMAX = 0
      IF( N .LT. 1 ) RETURN
      IDAMAX = 1
      IF(N.EQ.1)RETURN
      IF(INCX.EQ.1)GO TO 20
C
C        CODE FOR INCREMENT NOT EQUAL TO 1
C
      IX = 1
      DMAX = DABS(DX(1))
      IX = IX + INCX
      DO 10 I = 2,N
         IF(DABS(DX(IX)).LE.DMAX) GO TO 5
         IDAMAX = I
         DMAX = DABS(DX(IX))
    5    IX = IX + INCX
   10 CONTINUE
      RETURN
C
C        CODE FOR INCREMENT EQUAL TO 1
C
   20 DMAX = DABS(DX(1))
      DO 30 I = 2,N
         IF(DABS(DX(I)).LE.DMAX) GO TO 30
         IDAMAX = I
         DMAX = DABS(DX(I))
   30 CONTINUE
      RETURN
      END
      DOUBLE PRECISION FUNCTION D1MACH (IDUM)
      INTEGER IDUM
C-----------------------------------------------------------------------
C THIS ROUTINE COMPUTES THE UNIT ROUNDOFF OF THE MACHINE IN DOUBLE
C PRECISION.  THIS IS DEFINED AS THE SMALLEST POSITIVE MACHINE NUMBER
C U SUCH THAT  1.0E0 + U .NE. 1.0E0 (IN SINGLE PRECISION).
C-----------------------------------------------------------------------
      DOUBLE PRECISION U, COMP
      U = 1.0E0
 10   U = U*0.5E0
      COMP = 1.0E0 + U
      IF (COMP .NE. 1.0E0) GO TO 10
      D1MACH = U*2.0E0
      RETURN
C----------------------- END OF FUNCTION D1MACH ------------------------
      END
      SUBROUTINE XERRWV (MSG, NMES, NERR, IERT, NI, I1, I2, NR, R1, R2)
      CHARACTER*(*) MSG
      INTEGER NMES, NERR, IERT, NI, I1, I2, NR,
     1   LUN, LUNIT, MESFLG
      DOUBLE PRECISION R1, R2
C-----------------------------------------------------------------------
C SUBROUTINE XERRWV, AS GIVEN HERE, CONSTITUTES
C A SIMPLIFIED VERSION OF THE SLATEC ERROR HANDLING PACKAGE.
C WRITTEN BY A. C. HINDMARSH AT LLL.  VERSION OF JANUARY 23, 1980.
C MODIFIED BY L. R. PETZOLD, APRIL 1982.
C MODIFIED TO ANSI COMPATIBILITY BY PETER REICHRT, JULY 1991.
C THIS VERSION IS IN DOUBLE PRECISION.
C
C ALL ARGUMENTS ARE INPUT ARGUMENTS.
C
C MSG    = THE MESSAGE CHARACTER ARRAY.
C NMES   = THE LENGTH OF MSG (NOT USED).
C NERR   = THE ERROR NUMBER (NOT USED).
C IERT   = THE ERROR TYPE..
C          1 MEANS RECOVERABLE (CONTROL RETURNS TO CALLER).
C          2 MEANS FATAL (RUN IS ABORTED--SEE NOTE BELOW).
C NI     = NUMBER OF INTEGERS (0, 1, OR 2) TO BE PRINTED WITH MESSAGE.
C I1,I2  = INTEGERS TO BE PRINTED, DEPENDING ON NI.
C NR     = NUMBER OF REALS (0, 1, OR 2) TO BE PRINTED WITH MESSAGE.
C R1,R2  = REALS TO BE PRINTED, DEPENDING ON NI.
C
C THE DATA STATEMENT BELOW CONTAINS DEFAULT VALUES OF
C       MESFLG = PRINT CONTROL FLAG..
C                1 MEANS PRINT ALL MESSAGES (THE DEFAULT).
C                0 MEANS NO PRINTING.
C       LUNIT  = LOGICAL UNIT NUMBER FOR MESSAGES.
C                THE DEFAULT IS 3 (MACHINE-DEPENDENT).
C                TO CHANGE LUNIT, CHANGE THE DATA STATEMENT
C                BELOW.
C-----------------------------------------------------------------------
C THE FOLLOWING ARE INSTRUCTIONS FOR INSTALLING THIS ROUTINE
C IN DIFFERENT MACHINE ENVIRONMENTS.
C
C TO CHANGE THE DEFAULT OUTPUT UNIT, CHANGE THE DATA STATEMENT
C BELOW.
C
C FOR A DIFFERENT RUN-ABORT COMMAND, CHANGE THE STATEMENT FOLLOWING
C STATEMENT 100 AT THE END.
C-----------------------------------------------------------------------
      DATA MESFLG/1/,LUNIT/3/
C
      IF (MESFLG .EQ. 0) GO TO 100
C GET LOGICAL UNIT NUMBER. ---------------------------------------------
      LUN = LUNIT
      WRITE(LUN,200) MSG
  200 FORMAT(A)
      IF (NI .EQ. 1) WRITE (LUN, 20) I1
   20 FORMAT(6X,'IN ABOVE MESSAGE,  I1 =',I10)
      IF (NI .EQ. 2) WRITE (LUN, 30) I1,I2
   30 FORMAT(6X,'IN ABOVE MESSAGE,  I1 =',I10,3X,'I2 =',I10)
      IF (NR .EQ. 1) WRITE (LUN, 40) R1
   40 FORMAT(6X,'IN ABOVE MESSAGE,  R1 =',D21.13)
      IF (NR .EQ. 2) WRITE (LUN, 50) R1,R2
   50 FORMAT(6X,'IN ABOVE,  R1 =',D21.13,3X,'R2 =',D21.13)
C ABORT THE RUN IF IERT = 2. -------------------------------------------
  100 IF (IERT .NE. 2) RETURN
      STOP
C----------------------- END OF SUBROUTINE XERRWV ----------------------
      END
C
      DOUBLE PRECISION FUNCTION DBLEI(N)
      DBLEI=DBLE(FLOAT(N))
      RETURN
      END
