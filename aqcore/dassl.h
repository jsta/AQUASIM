////////////////////////////////   dassl.h   /////////////////////////////////
//
//              date:       person:           comments:
//
// creation:    18.11.91    Peter Reichert
// revisions:   
//
//////////////////////////////////////////////////////////////////////////////
//
// "dassl" is a C++ translation of the FORTRAN program DASSL by L. Petzold
// =======================================================================
//
//////////////////////////////////////////////////////////////////////////////
//
// Note: The following comments are the original comments of the FORTRAN
// ----- package. Due to the different range of indices of arrays in C and
//       FORTRAN all indices have to be reduced by one for the C++ versions.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DASSL_H
#define DASSL_H

#include "all.h"

//////////////////////////////////////////////////////////////////////////////

void dassl(void (*res)(REAL* t, REAL y[], REAL yprime[], REAL delta[],
                       INTEGER* ires, REAL rpar[], INTEGER ipar[]),
           INTEGER* neq, REAL* t, REAL y[],
           REAL yprime[], REAL* tout, INTEGER info[],
           REAL rtol[], REAL atol[], INTEGER* idid,
           REAL rwork[], INTEGER* lrw, INTEGER iwork[], INTEGER* liw,
           REAL rpar[], INTEGER ipar[],
           void (*jac)(REAL* t, REAL y[], REAL yprime[], REAL pd[],
                       REAL* cj, REAL rpar[], INTEGER ipar[]),
					   std::ostream& errmes = std::cout, CARDINAL maxnumsteps=1000);

/****BEGIN PROLOGUE  DASSL
 ****DATE WRITTEN   830315   (YYMMDD)
 ****REVISION DATE  830315   (YYMMDD)
 ****CATEGORY NO.  D2A2
 ****KEYWORDS  DIFFERENTIAL/ALGEBRAIC,BACKWARD DIFFERENTIATION FORMULAS
 *             IMPLICIT DIFFERENTIAL SYSTEMS
 ****AUTHOR  PETZOLD,LINDA R.
 *             APPLIED MATHEMATICS DIVISION 8331
 *             SANDIA NATIONAL LABORATORIES
 *             LIVERMORE, CA.    94550
 ****PURPOSE  DIFFERENTIAL/ALGEBRAIC SYSTEM SOLVER
 ****DESCRIPTION
 *  ---------------------------------------------------------------------
 *
 *  THIS CODE SOLVES A SYSTEM OF DIFFERENTIAL/
 *  ALGEBRAIC EQUATIONS OF THE FORM
 *  G(T,Y,YPRIME) = 0.
 *
 *  SUBROUTINE DASSL USES THE BACKWARD
 *  DIFFERENTIATION FORMULAS OF ORDERS ONE
 *  THROUGH FIVE TO SOLVE A SYSTEM OF THE ABOVE
 *  FORM FOR Y AND YPRIME. VALUES FOR Y
 *  AND YPRIME AT THE INITIAL TIME MUST
 *  BE GIVEN AS INPUT. THESE VALUES MUST
 *  BE CONSISTENT, (THAT IS. IF T,Y,YPRIME
 *  ARE THE GIVEN INITIAL VALUES, THEY MUST
 *  SATISFY G(T,Y,YPRIME) = 0.)
 *  THE SUBROUTINE SOLVES THE SYSTEM FROM T TO TOUT. IT IS
 *  EASY TO CONTINUE THE SOLUTION TO GET RESULTS
 *  AT ADDITIONAL TOUT. THIS IS THE INTERVAL
 *  MODE OF OPERATION. INTERMEDIATE RESULTS CAN
 *  ALSO BE OBTAINED EASILY BY USING THE INTERMEDIATE-
 *  OUTPUT CAPABILITY.
 *
 *
 *  ------------DESCRIPTION OF ARGUMENTS TO DASSL------------------------
 *  ------------(AN OVERVIEW)--------------------------------------------
 *
 *  THE PARAMETERS ARE
 *
 *  RES -- THIS IS A SUBROUTINE WHICH YOU PROVIDE
 *         TO DEFINE THE DIFFERENTIAL/ALGEBRAIC
 *         SYSTEM
 *
 *  NEQ -- THIS IS THE NUMBER OF EQUATIONS
 *         TO BE SOLVED
 *
 *  T -- THIS IS THE CURRENT VALUE OF THE
 *       INDEPENDENT VARIABLE.
 *
 *  TOUT -- THIS IS A POINT AT WHICH A SOLUTION
 *      IS DESIRED.
 *
 *  INFO(*) -- THE BASIC TASK OF THE CODE IS
 *             TO SOLVE THE SYSTEM FROM T TO
 *             TOUT AND RETURN AN ANSWER AT TOUT.
 *             INFO(*) IS AN INTEGER ARRAY WHICH IS
 *             USED TO COMMUNICATE EXACTLY HOW YOU
 *             WANT THIS TASK TO BE CARRIED OUT.
 *
 *  Y(*) -- THIS ARRAY CONTAINS THE SOLUTION
 *          COMPONENTS AT T
 *
 *  YPRIME(*) -- THIS ARRAY CONTAINS THE DERIVATIVES
 *               OF THE SOLUTION COMPONENTS AT T
 *
 *  RTOL,ATOL -- THESE QUANTITIES REPRESENT
 *               ABSOLUTE AND RELATIVE ERROR
 *               TOLERANCES WHICH YOU PROVIDE TO INDICATE
 *               HOW ACCURATELY YOU WISH THE SOLUTION
 *               TO BE COMPUTED. YOU MAY CHOOSE THEM
 *               TO BE BOTH SCALARS OR ELSE BOTH
 *               VECTORS.
 *
 *  IDID -- THIS SCALAR QUANTITY IS AN INDICATOR REPORTING
 *          WHAT THE CODE DID. YOU MUST MONITOR THIS
 *          INTEGER VARIABLE TO DECIDE WHAT ACTION TO
 *          TAKE NEXT.
 *
 *  RWORK(*),LRW -- RWORK(*) IS A REAL WORK ARRAY OF
 *                  LENGTH LRW WHICH PROVIDES THE CODE
 *                  WITH NEEDED STORAGE SPACE.
 *
 *  IWORK(*),LIW -- IWORK(*) IS AN INTEGER WORK ARRAY
 *                  OF LENGTH LIW WHICH PROVIDES THE CODE
 *                  WITH NEEDED STORAGE SPACE.
 *
 *  RPAR,IPAR -- THESE ARE REAL AND INTEGER PARAMETER
 *               ARRAYS WHICH YOU CAN USE FOR
 *               COMMUNICATION BETWEEN YOUR CALLING
 *               PROGRAM AND THE RES SUBROUTINE
 *               (AND THE JAC SUBROUTINE)
 *
 *  JAC -- THIS IS THE NAME OF A SUBROUTINE WHICH YOU
 *         MAY CHOOSE TO PROVIDE FOR DEFINING
 *         A MATRIX OF PARTIAL DERIVATIVES
 *         DESCRIBED BELOW.
 *
 *  QUANTITIES WHICH ARE USED AS INPUT ITEMS ARE
 *     NEQ,T,Y(*),YPRIME(*),TOUT,INFO(*),
 *     RTOL,ATOL,RWORK(1),RWORK(2),RWORK(3),LRW,IWORK(1),
 *     IWORK(2),IWORK(3),AND LIW.
 *
 *  QUANTITIES WHICH MAY BE ALTERED BY THE CODE ARE
 *     T,Y(*),YPRIME(*),INFO(1),RTOL,ATOL,
 *     IDID,RWORK(*) AND IWORK(*)
 *
 *  ----------INPUT-WHAT TO DO ON THE FIRST CALL TO DASSL---------------
 *
 *
 *  THE FIRST CALL OF THE CODE IS DEFINED TO BE THE START OF EACH NEW
 *  PROBLEM. READ THROUGH THE DESCRIPTIONS OF ALL THE FOLLOWING ITEMS,
 *  PROVIDE SUFFICIENT STORAGE SPACE FOR DESIGNATED ARRAYS, SET
 *  APPROPRIATE VARIABLES FOR THE INITIALIZATION OF THE PROBLEM, AND
 *  GIVE INFORMATION ABOUT HOW YOU WANT THE PROBLEM TO BE SOLVED.
 *
 *
 *  RES -- PROVIDE A SUBROUTINE OF THE FORM
 *             SUBROUTINE RES(T,Y,YPRIME,DELTA,IRES,RPAR,IPAR)
 *         TO DEFINE THE SYSTEM OF DIFFERENTIAL/ALGEBRAIC
 *         EQUATIONS WHICH IS TO BE SOLVED. FOR THE GIVEN VALUES
 *         OF T,Y AND YPRIME, THE SUBROUTINE SHOULD
 *         RETURN THE RESIDUAL OF THE DIFFERENTIAL/ALGEBRAIC
 *         SYSTEM
 *             DELTA = G(T,Y,YPRIME)
 *         (DELTA(*) IS A VECTOR OF LENGTH NEQ WHICH IS
 *         OUTPUT FOR RES.)
 *
 *         SUBROUTINE RES MUST NOT ALTER T,Y OR YPRIME.
 *         YOU MUST DECLARE THE NAME RES IN AN EXTERNAL
 *         STATEMENT IN YOUR PROGRAM THAT CALLS DASSL.
 *         YOU MUST DIMENSION Y,YPRIME AND DELTA IN RES.
 *
 *         IRES IS AN INTEGER FLAG WHICH IS ALWAYS EQUAL TO
 *         ZERO ON INPUT.  SUBROUTINE RES SHOULD ALTER IRES
 *         ONLY IF IT ENCOUNTERS AN ILLEGAL VALUE OF Y OR
 *         A STOP CONDITION.  SET IRES = -1 IF AN INPUT VALUE
 *         IS ILLEGAL, AND DASSL WILL TRY TO SOLVE THE PROBLEM
 *         WITHOUT GETTING IRES = -1.  IF IRES = -2, DASSL
 *         WILL RETURN CONTROL TO THE CALLING PROGRAM
 *         WITH IDID = -11.
 *
 *         RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
 *         YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING PROGRAM
 *         AND SUBROUTINE RES. THEY ARE NOT ALTERED BY DASSL. IF YOU
 *         DO NOT NEED RPAR OR IPAR, IGNORE THESE PARAMETERS BY TREAT-
 *         ING THEM AS DUMMY ARGUMENTS. IF YOU DO CHOOSE TO USE THEM,
 *         DIMENSION THEM IN YOUR CALLING PROGRAM AND IN RES AS ARRAYS
 *         OF APPROPRIATE LENGTH.
 *
 *  NEQ -- SET IT TO THE NUMBER OF DIFFERENTIAL EQUATIONS.
 *         (NEQ .GE. 1)
 *
 *  T -- SET IT TO THE INITIAL POINT OF THE INTEGRATION.
 *       T MUST BE DEFINED AS A VARIABLE.
 *
 *  Y(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF THE NEQ SOLUTION
 *          COMPONENTS AT THE INITIAL POINT. YOU MUST DIMENSION Y OF
 *          LENGTH AT LEAST NEQ IN YOUR CALLING PROGRAM.
 *
 *  YPRIME(*) -- SET THIS VECTOR TO THE INITIAL VALUES OF
 *               THE NEQ FIRST DERIVATIVES OF THE SOLUTION
 *               COMPONENTS AT THE INITIAL POINT. YOU
 *               MUST DIMENSION YPRIME AT LEAST NEQ
 *               IN YOUR CALLING PROGRAM.  IF YOU DO NOT
 *               KNOW INITIAL VALUES OF SOME OF THE SOLUTION
 *               COMPONENTS, SEE THE EXPLANATION OF INFO(11).
 *
 *  TOUT - SET IT TO THE FIRST POINT AT WHICH A SOLUTION
 *         IS DESIRED. YOU CAN NOT TAKE TOUT = T.
 *         INTEGRATION EITHER FORWARD IN T (TOUT .GT. T) OR
 *         BACKWARD IN T (TOUT .LT. T) IS PERMITTED.
 *
 *         THE CODE ADVANCES THE SOLUTION FROM T TO TOUT USING
 *         STEP SIZES WHICH ARE AUTOMATICALLY SELECTED SO AS TO
 *         ACHIEVE THE DESIRED ACCURACY. IF YOU WISH, THE CODE WILL
 *         RETURN WITH THE SOLUTION AND ITS DERIVATIVE AT
 *         INTERMEDIATE STEPS (INTERMEDIATE-OUTPUT MODE) SO THAT
 *         YOU CAN MONITOR THEM, BUT YOU STILL MUST PROVIDE TOUT IN
 *         ACCORD WITH THE BASIC AIM OF THE CODE.
 *
 *         THE FIRST STEP TAKEN BY THE CODE IS A CRITICAL ONE
 *         BECAUSE IT MUST REFLECT HOW FAST THE SOLUTION CHANGES NEAR
 *         THE INITIAL POINT. THE CODE AUTOMATICALLY SELECTS AN
 *         INITIAL STEP SIZE WHICH IS PRACTICALLY ALWAYS SUITABLE FOR
 *         THE PROBLEM. BY USING THE FACT THAT THE CODE WILL NOT STEP
 *         PAST TOUT IN THE FIRST STEP, YOU COULD, IF NECESSARY,
 *         RESTRICT THE LENGTH OF THE INITIAL STEP SIZE.
 *
 *         FOR SOME PROBLEMS IT MAY NOT BE PERMISSABLE TO INTEGRATE
 *         PAST A POINT TSTOP BECAUSE A DISCONTINUITY OCCURS THERE
 *         OR THE SOLUTION OR ITS DERIVATIVE IS NOT DEFINED BEYOND
 *         TSTOP. WHEN YOU HAVE DECLARED A TSTOP POINT (SEE INFO(4)
 *         AND RWORK(1)), YOU HAVE TOLD THE CODE NOT TO INTEGRATE
 *         PAST TSTOP. IN THIS CASE ANY TOUT BEYOND TSTOP IS INVALID
 *         INPUT.
 *
 *  INFO(*) - USE THE INFO ARRAY TO GIVE THE CODE MORE DETAILS ABOUT
 *            HOW YOU WANT YOUR PROBLEM SOLVED. THIS ARRAY SHOULD BE
 *            DIMENSIONED OF LENGTH 15, THOUGH DASSL USES
 *            ONLY THE FIRST NINE ENTRIES. YOU MUST RESPOND TO ALL OF
 *            THE FOLLOWING ITEMS WHICH ARE ARRANGED AS QUESTIONS. THE
 *            SIMPLEST USE OF THE CODE CORRESPONDS TO ANSWERING ALL
 *            QUESTIONS AS YES ,I.E. SETTING ALL ENTRIES OF INFO TO 0.
 *
 *       INFO(1) - THIS PARAMETER ENABLES THE CODE TO INITIALIZE
 *              ITSELF. YOU MUST SET IT TO INDICATE THE START OF EVERY
 *              NEW PROBLEM.
 *
 *          **** IS THIS THE FIRST CALL FOR THIS PROBLEM ...
 *                YES - SET INFO(1) = 0
 *                 NO - NOT APPLICABLE HERE.
 *                      SEE BELOW FOR CONTINUATION CALLS.  ****
 *
 *       INFO(2) - HOW MUCH ACCURACY YOU WANT OF YOUR SOLUTION
 *              IS SPECIFIED BY THE ERROR TOLERANCES RTOL AND ATOL.
 *              THE SIMPLEST USE IS TO TAKE THEM BOTH TO BE SCALARS.
 *              TO OBTAIN MORE FLEXIBILITY, THEY CAN BOTH BE VECTORS.
 *              THE CODE MUST BE TOLD YOUR CHOICE.
 *
 *          **** ARE BOTH ERROR TOLERANCES RTOL, ATOL SCALARS ...
 *                YES - SET INFO(2) = 0
 *                      AND INPUT SCALARS FOR BOTH RTOL AND ATOL
 *                 NO - SET INFO(2) = 1
 *                      AND INPUT ARRAYS FOR BOTH RTOL AND ATOL ****
 *
 *       INFO(3) - THE CODE INTEGRATES FROM T IN THE DIRECTION
 *              OF TOUT BY STEPS. IF YOU WISH, IT WILL RETURN THE
 *              COMPUTED SOLUTION AND DERIVATIVE AT THE NEXT
 *              INTERMEDIATE STEP (THE INTERMEDIATE-OUTPUT MODE) OR
 *              TOUT, WHICHEVER COMES FIRST. THIS IS A GOOD WAY TO
 *              PROCEED IF YOU WANT TO SEE THE BEHAVIOR OF THE SOLUTION.
 *              IF YOU MUST HAVE SOLUTIONS AT A GREAT MANY SPECIFIC
 *              TOUT POINTS, THIS CODE WILL COMPUTE THEM EFFICIENTLY.
 *
 *          **** DO YOU WANT THE SOLUTION ONLY AT
 *                TOUT (AND NOT AT THE NEXT INTERMEDIATE STEP) ...
 *                 YES - SET INFO(3) = 0
 *                  NO - SET INFO(3) = 1 ****
 *
 *       INFO(4) - TO HANDLE SOLUTIONS AT A GREAT MANY SPECIFIC
 *              VALUES TOUT EFFICIENTLY, THIS CODE MAY INTEGRATE PAST
 *              TOUT AND INTERPOLATE TO OBTAIN THE RESULT AT TOUT.
 *              SOMETIMES IT IS NOT POSSIBLE TO INTEGRATE BEYOND SOME
 *              POINT TSTOP BECAUSE THE EQUATION CHANGES THERE OR IT IS
 *              NOT DEFINED PAST TSTOP. THEN YOU MUST TELL THE CODE
 *              NOT TO GO PAST.
 *
 *           **** CAN THE INTEGRATION BE CARRIED OUT WITHOUT ANY
 *                RESTRICTIONS ON THE INDEPENDENT VARIABLE T ...
 *                 YES - SET INFO(4)=0
 *                  NO - SET INFO(4)=1
 *                       AND DEFINE THE STOPPING POINT TSTOP BY
 *                       SETTING RWORK(1)=TSTOP ****
 *
 *       INFO(5) - TO SOLVE DIFFERENTIAL/ALGEBRAIC PROBLEMS IT IS
 *              NECESSARY TO USE A MATRIX OF PARTIAL DERIVATIVES OF THE
 *              SYSTEM OF DIFFERENTIAL EQUATIONS.  IF YOU DO NOT
 *              PROVIDE A SUBROUTINE TO EVALUATE IT ANALYTICALLY (SEE
 *              DESCRIPTION OF THE ITEM JAC IN THE CALL LIST), IT WILL
 *              BE APPROXIMATED BY NUMERICAL DIFFERENCING IN THIS CODE.
 *              ALTHOUGH IT IS LESS TROUBLE FOR YOU TO HAVE THE CODE
 *              COMPUTE PARTIAL DERIVATIVES BY NUMERICAL DIFFERENCING,
 *              THE SOLUTION WILL BE MORE RELIABLE IF YOU PROVIDE THE
 *              DERIVATIVES VIA JAC. SOMETIMES NUMERICAL DIFFERENCING
 *              IS CHEAPER THAN EVALUATING DERIVATIVES IN JAC AND
 *              SOMETIMES IT IS NOT - THIS DEPENDS ON YOUR PROBLEM.
 *
 *           **** DO YOU WANT THE CODE TO EVALUATE THE PARTIAL
 *                  DERIVATIVES AUTOMATICALLY BY NUMERICAL DIFFERENCES ...
 *                   YES - SET INFO(5)=0
 *                    NO - SET INFO(5)=1
 *                  AND PROVIDE SUBROUTINE JAC FOR EVALUATING THE
 *                  MATRIX OF PARTIAL DERIVATIVES ****
 *
 *       INFO(6) - DASSL WILL PERFORM MUCH BETTER IF THE MATRIX OF
 *              PARTIAL DERIVATIVES, DG/DY + CJ*DG/DYPRIME,
 *              (HERE CJ IS A SCALAR DETERMINED BY DASSL)
 *              IS BANDED AND THE CODE IS TOLD THIS. IN THIS
 *              CASE, THE STORAGE NEEDED WILL BE GREATLY REDUCED,
 *              NUMERICAL DIFFERENCING WILL BE PERFORMED MUCH CHEAPER,
 *              AND A NUMBER OF IMPORTANT ALGORITHMS WILL EXECUTE MUCH
 *              FASTER. THE DIFFERENTIAL EQUATION IS SAID TO HAVE
 *              HALF-BANDWIDTHS ML (LOWER) AND MU (UPPER) IF EQUATION I
 *              INVOLVES ONLY UNKNOWNS Y(J) WITH
 *                             I-ML .LE. J .LE. I+MU
 *              FOR ALL I=1,2,...,NEQ. THUS, ML AND MU ARE THE WIDTHS
 *              OF THE LOWER AND UPPER PARTS OF THE BAND, RESPECTIVELY,
 *              WITH THE MAIN DIAGONAL BEING EXCLUDED. IF YOU DO NOT
 *              INDICATE THAT THE EQUATION HAS A BANDED MATRIX OF PARTIAL
 *                 DERIVATIVES
 *              THE CODE WORKS WITH A FULL MATRIX OF NEQ**2 ELEMENTS
 *              (STORED IN THE CONVENTIONAL WAY). COMPUTATIONS WITH
 *              BANDED MATRICES COST LESS TIME AND STORAGE THAN WITH
 *              FULL MATRICES IF  2*ML+MU .LT. NEQ.  IF YOU TELL THE
 *              CODE THAT THE MATRIX OF PARTIAL DERIVATIVES HAS A BANDED
 *              STRUCTURE AND YOU WANT TO PROVIDE SUBROUTINE JAC TO
 *              COMPUTE THE PARTIAL DERIVATIVES, THEN YOU MUST BE CAREFUL
 *              TO STORE THE ELEMENTS OF THE MATRIX IN THE SPECIAL FORM
 *              INDICATED IN THE DESCRIPTION OF JAC.
 *
 *          **** DO YOU WANT TO SOLVE THE PROBLEM USING A FULL
 *               (DENSE) MATRIX (AND NOT A SPECIAL BANDED
 *               STRUCTURE) ...
 *                YES - SET INFO(6)=0
 *                 NO - SET INFO(6)=1
 *                       AND PROVIDE THE LOWER (ML) AND UPPER (MU)
 *                       BANDWIDTHS BY SETTING
 *                       IWORK(1)=ML
 *                       IWORK(2)=MU ****
 *
 *
 *        INFO(7) -- YOU CAN SPECIFY A MAXIMUM (ABSOLUTE VALUE OF)
 *              STEPSIZE, SO THAT THE CODE
 *              WILL AVOID PASSING OVER VERY
 *              LARGE REGIONS.
 *
 *          ****  DO YOU WANT THE CODE TO DECIDE
 *                ON ITS OWN MAXIMUM STEPSIZE?
 *                YES - SET INFO(7)=0
 *                 NO - SET INFO(7)=1
 *                      AND DEFINE HMAX BY SETTING
 *                      RWORK(2)=HMAX ****
 *
 *        INFO(8) -- DIFFERENTIAL/ALGEBRAIC PROBLEMS
 *              MAY OCCAISIONALLY SUFFER FROM
 *              SEVERE SCALING DIFFICULTIES ON THE
 *              FIRST STEP. IF YOU KNOW A GREAT DEAL
 *              ABOUT THE SCALING OF YOUR PROBLEM, YOU CAN
 *              HELP TO ALLEVIATE THIS PROBLEM BY
 *              SPECIFYING AN INITIAL STEPSIZE HO.
 *
 *          ****  DO YOU WANT THE CODE TO DEFINE
 *                ITS OWN INITIAL STEPSIZE?
 *                YES - SET INFO(8)=0
 *                 NO - SET INFO(8)=1
 *                      AND DEFINE HO BY SETTING
 *                      RWORK(3)=HO ****
 *
 *        INFO(9) -- IF STORAGE IS A SEVERE PROBLEM,
 *              YOU CAN SAVE SOME LOCATIONS BY
 *              RESTRICTING THE MAXIMUM ORDER MAXORD.
 *              THE DEFAULT VALUE IS 5. FOR EACH
 *              ORDER DECREASE BELOW 5, THE CODE
 *              REQUIRES NEQ FEWER LOCATIONS, HOWEVER
 *              IT IS LIKELY TO BE SLOWER. IN ANY
 *              CASE, YOU MUST HAVE 1 .LE. MAXORD .LE. 5
 *          ****  DO YOU WANT THE MAXIMUM ORDER TO
 *                DEFAULT TO 5?
 *                YES - SET INFO(9)=0
 *                 NO - SET INFO(9)=1
 *                      AND DEFINE MAXORD BY SETTING
 *                      IWORK(3)=MAXORD ****
 *
 *        INFO(10) --IF YOU KNOW THAT THE SOLUTIONS TO YOUR EQUATIONS WILL
 *               ALWAYS BE NONNEGATIVE, IT MAY HELP TO SET THIS
 *               PARAMETER.  HOWEVER, IT IS PROBABLY BEST TO
 *               TRY THE CODE WITHOUT USING THIS OPTION FIRST,
 *               AND ONLY TO USE THIS OPTION IF THAT DOESN'T
 *               WORK VERY WELL.
 *           ****  DO YOU WANT THE CODE TO SOLVE THE PROBLEM WITHOUT
 *                 INVOKING ANY SPECIAL NONNEGATIVITY CONSTRAINTS?
 *                  YES - SET INFO(10)=0
 *                   NO - SET INFO(10)=1
 *
 *        INFO(11) --DASSL NORMALLY REQUIRES THE INITIAL T,
 *               Y, AND YPRIME TO BE CONSISTENT.  THAT IS,
 *               YOU MUST HAVE G(T,Y,YPRIME) = 0 AT THE INITIAL
 *               TIME.  IF YOU DO NOT KNOW THE INITIAL
 *               DERIVATIVE PRECISELY, YOU CAN LET DASSL TRY
 *               TO COMPUTE IT.
 *          ****   ARE THE INITIAL T, Y, YPRIME CONSISTENT?
 *                 YES - SET INFO(11) = 0
 *                  NO - SET INFO(11) = 1,
 *                       AND SET YPRIME TO AN INITIAL APPROXIMATION
 *                       TO YPRIME.  (IF YOU HAVE NO IDEA WHAT
 *                       YPRIME SHOULD BE, SET IT TO ZERO. NOTE
 *                       THAT THE INITIAL Y SHOULD BE SUCH
 *                       THAT THERE MUST EXIST A YPRIME SO THAT
 *                       G(T,Y,YPRIME) = 0.)
 *
 *   RTOL, ATOL -- YOU MUST ASSIGN RELATIVE (RTOL) AND ABSOLUTE (ATOL
 *               ERROR TOLERANCES TO TELL THE CODE HOW ACCURATELY YOU WANT
 *               THE SOLUTION TO BE COMPUTED. THEY MUST BE DEFINED AS
 *               VARIABLES BECAUSE THE CODE MAY CHANGE THEM. YOU HAVE TWO
 *               CHOICES --
 *                     BOTH RTOL AND ATOL ARE SCALARS. (INFO(2)=0)
 *                     BOTH RTOL AND ATOL ARE VECTORS. (INFO(2)=1)
 *               IN EITHER CASE ALL COMPONENTS MUST BE NON-NEGATIVE.
 *
 *               THE TOLERANCES ARE USED BY THE CODE IN A LOCAL ERROR TEST
 *               AT EACH STEP WHICH REQUIRES ROUGHLY THAT
 *                     ABS(LOCAL ERROR) .LE. RTOL*ABS(Y)+ATOL
 *               FOR EACH VECTOR COMPONENT.
 *               (MORE SPECIFICALLY, A ROOT-MEAN-SQUARE NORM IS USED TO
 *               MEASURE THE SIZE OF VECTORS, AND THE ERROR TEST USES THE
 *               MAGNITUDE OF THE SOLUTION AT THE BEGINNING OF THE STEP.)
 *
 *               THE TRUE (GLOBAL) ERROR IS THE DIFFERENCE BETWEEN THE TRUE
 *               SOLUTION OF THE INITIAL VALUE PROBLEM AND THE COMPUTED
 *               APPROXIMATION. PRACTICALLY ALL PRESENT DAY CODES.
 *               INCLUDING THIS ONE, CONTROL THE LOCAL ERROR AT EACH STEP
 *               AND DO NOT EVEN ATTEMPT TO CONTROL THE GLOBAL ERROR
 *               DIRECTLY.
 *               USUALLY, BUT NOT ALWAYS, THE TRUE ACCURACY OF
 *               THE COMPUTED Y IS COMPARABLE TO THE ERROR TOLERANCES. THIS
 *               CODE WILL USUALLY, BUT NOT ALWAYS, DELIVER A MORE ACCURATE
 *               SOLUTION IF YOU REDUCE THE TOLERANCES AND INTEGRATE AGAIN.
 *               BY COMPARING TWO SUCH SOLUTIONS YOU CAN GET A FAIRLY
 *               RELIABLE IDEA OF THE TRUE ERROR IN THE SOLUTION AT THE
 *               BIGGER TOLERANCES.
 *
 *               SETTING ATOL=0. RESULTS IN A PURE RELATIVE ERROR TEST ON
 *               THAT COMPONENT. SETTING RTOL=0. RESULTS IN A PURE ABSOLUTE
 *               ERROR TEST ON THAT COMPONENT. A MIXED TEST WITH NON-ZERO
 *               RTOL AND ATOL CORRESPONDS ROUGHLY TO A RELATIVE ERROR
 *               TEST WHEN THE SOLUTION COMPONENT IS MUCH BIGGER THAN ATOL
 *               AND TO AN ABSOLUTE ERROR TEST WHEN THE SOLUTION COMPONENT
 *               IS SMALLER THAN THE THRESHOLD ATOL.
 *
 *               THE CODE WILL NOT ATTEMPT TO COMPUTE A SOLUTION AT AN
 *               ACCURACY UNREASONABLE FOR THE MACHINE BEING USED. IT WILL
 *               ADVISE YOU IF YOU ASK FOR TOO MUCH ACCURACY AND INFORM
 *               YOU AS TO THE MAXIMUM ACCURACY IT BELIEVES POSSIBLE.
 *
 *  RWORK(*) -- DIMENSION THIS REAL WORK ARRAY OF LENGTH LRW IN YOUR
 *               CALLING PROGRAM.
 *
 *  LRW -- SET IT TO THE DECLARED LENGTH OF THE RWORK ARRAY.
 *               YOU MUST HAVE
 *                    LRW .GE. 40+(MAXORD+4)*NEQ+NEQ**2
 *               FOR THE FULL (DENSE) JACOBIAN CASE (WHEN INFO(6)=0),  OR
 *                    LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
 *               FOR THE BANDED USER-DEFINED JACOBIAN CASE
 *               (WHEN INFO(5)=1 AND INFO(6)=1), OR
 *                     LRW .GE. 40+(MAXORD+4)*NEQ+(2*ML+MU+1)*NEQ
 *                           +2*(NEQ/(ML+MU+1)+1)
 *               FOR THE BANDED FINITE-DIFFERENCE-GENERATED JACOBIAN CASE
 *               (WHEN INFO(5)=0 AND INFO(6)=1)
 *
 *  IWORK(*) -- DIMENSION THIS INTEGER WORK ARRAY OF LENGTH LIW IN
 *             YOUR CALLING PROGRAM.
 *
 *  LIW -- SET IT TO THE DECLARED LENGTH OF THE IWORK ARRAY.
 *               YOU MUST HAVE LIW .GE. 20+NEQ
 *
 *  RPAR, IPAR -- THESE ARE PARAMETER ARRAYS, OF REAL AND INTEGER
 *               TYPE, RESPECTIVELY. YOU CAN USE THEM FOR COMMUNICATION
 *               BETWEEN YOUR PROGRAM THAT CALLS DASSL AND THE
 *               RES SUBROUTINE (AND THE JAC SUBROUTINE). THEY ARE NOT
 *               ALTERED BY DASSL. IF YOU DO NOT NEED RPAR OR IPAR, IGNORE
 *               THESE PARAMETERS BY TREATING THEM AS DUMMY ARGUMENTS. IF
 *               YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN YOUR CALLING
 *               PROGRAM AND IN RES (AND IN JAC) AS ARRAYS OF APPROPRIATE
 *               LENGTH.
 *
 *  JAC -- IF YOU HAVE SET INFO(5)=0, YOU CAN IGNORE THIS PARAMETER
 *               BY TREATING IT AS A DUMMY ARGUMENT. OTHERWISE, YOU MUST
 *               PROVIDE A SUBROUTINE OF THE FORM
 *               JAC(T,Y,YPRIME,PD,CJ,RPAR,IPAR)
 *               TO DEFINE THE MATRIX OF PARTIAL DERIVATIVES
 *               PD=DG/DY+CJ*DG/DYPRIME
 *               CJ IS A SCALAR WHICH IS INPUT TO JAC.
 *               FOR THE GIVEN VALUES OF T,Y,YPRIME, THE
 *               SUBROUTINE MUST EVALUATE THE NON-ZERO PARTIAL
 *               DERIVATIVES FOR EACH EQUATION AND EACH SOLUTION
 *               COMPOWENT, AND STORE THESE VALUES IN THE
 *               MATRIX PD. THE ELEMENTS OF PD ARE SET TO ZERO
 *               BEFORE EACH CALL TO JAC SO ONLY NON-ZERO ELEMENTS
 *               NEED TO BE DEFINED.
 *
 *               SUBROUTINE JAC MUST NOT ALTER T,Y,(*),YPRIME(*),OR CJ.
 *               YOU MUST DECLARE THE NAME JAC IN AN
 *               EXTERNAL STATEMENT IN YOUR PROGRAM THAT CALLS
 *               DASSL. YOU MUST DIMENSION Y, YPRIME AND PD
 *               IN JAC.
 *
 *               THE WAY YOU MUST STORE THE ELEMENTS INTO THE PD MATRIX
 *               DEPENDS ON THE STRUCTURE OF THE MATRIX WHICH YOU
 *               INDICATED BY INFO(6).
 *               *** INFO(6)=0 -- FULL (DENSE) MATRIX ***
 *                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
 *                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
 *               STORE IT IN PD ACCORDING TO
 *                   PD(I,J) = * DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)*
 *               *** INFO(6)=1 -- BANDED JACOBIAN WITH ML LOWER AND MU
 *                   UPPER DIAGONAL BANDS (REFER TO INFO(6) DESCRIPTION OF
 *                   ML AND MU) ***
 *                   WHEN YOU EVALUATE THE (NON-ZERO) PARTIAL DERIVATIVE
 *                   OF EQUATION I WITH RESPECT TO VARIABLE J, YOU MUST
 *                   STORE IT IN PD ACCORDING TO
 *                   IROW = I - J + ML + MU + 1
 *                   PD(IROW,J) = *DG(I)/DY(J)+CJ*DG(I)/DYPRIME(J)*
 *               RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
 *               YOU CAN USE FOR COMMUNICATION BETWEEN YOUR CALLING
 *               PROGRAM AND YOUR JACOBIAN SUBROUTINE JAC. THEY ARE NOT
 *               ALTERED BY DASSL. IF YOU DO NOT NEED RPAR OR IPAR, IGNORE
 *               THESE PARAMETERS BY TREATING THEM AS DUMMY ARGUMENTS. IF
 *               YOU DO CHOOSE TO USE THEM, DIMENSION THEM IN YOUR CALLING
 *               PROGRAM AND IN JAC AS ARRAYS OF APPROPRIATE LENGTH.
 *
 *
 *
 *  OPTIONALLY REPLACEABLE NORM ROUTINE:
 *  DASSL USES A WEIGHTED NORM DDANRM TO MEASURE THE SIZE
 *  OF VECTORS SUCH AS THE ESTIMATED ERROR IN EACH STEP.
 *  A FUNCTION SUBPROGRAM
 *    DOUBLE PRECISION FUNCTION DDANRM(NEQ,V,WT,RPAR,IPAR)
 *    DIMENSION V(NEQ),WT(NEQ)
 *  IS USED TO DEFINE THIS NORM.  HERE, V IS THE VECTOR
 *  WHOSE NORM IS TO BE COMPUTED, AND WT IS A VECTOR OF
 *  WEIGHTS.  A DDANRM ROUTINE HAS BEEN INCLUDED WITH DASSL
 *  WHICH COMPUTES THE WEIGHTED ROOT-MEAN-SQUARE NORM
 *  GIVEN BY
 *    DDANRM=SQRT((1/NEQ)*SUM(V(I)/WT(I))**2)
 *  THIS NORM IS SUITABLE FOR MOST PROBLEMS.  IN SOME
 *  SPECIAL CASES, IT MAY BE MORE CONVENIENT AND/OR
 *  EFFICIENT TO DEFINE YOUR OWN NORM BY WRITING A FUNCTION
 *  SUBPROGRAM TO BE CALLED INSTEAD OF DDANRM.  THIS SHOULD
 *  HOWEVER, BE ATTEMPTED ONLY AFTER CAREFUL THOUGHT AND
 *  CONSIDERATION.
 *
 *
 *------OUTPUT-AFTER ANY RETURN FROM DASSL----
 *
 *  THE PRINCIPAL AIM OF THE CODE IS TO RETURN A COMPUTED SOLUTION AT
 *  TOUT, ALTHOUGH IT IS ALSO POSSIBLE TO OBTAIN INTERMEDIATE RESULTS
 *  ALONG THE WAY. TO FIND OUT WHETHER THE CODE ACHIEVED ITS GOAL
 *  OR IF THE INTEGRATION PROCESS WAS INTERRUPTED BEFORE THE TASK WAS
 *  COMPLETED, YOU MUST CHECK THE IDID PARAMETER.
 *
 *
 *   T -- THE SOLUTION WAS SUCCESSFULLY ADVANCED TO THE
 *               OUTPUT VALUE OF T.
 *
 *   Y(*) -- CONTAINS THE COMPUTED SOLUTION APPROXIMATION AT T.
 *
 *   YPRIME(*) -- CONTAINS THE COMPUTED DERIVATIVE
 *               APPROXIMATION AT T
 *
 *   IDID -- REPORTS WHAT THE CODE DID
 *
 *                     *** TASK COMPLETED ***
 *                REPORTED BY POSITIVE VALUES OF IDID
 *
 *           IDID = 1 -- A STEP WAS SUCCESSFULLY TAKEN IN THE
 *                   INTERMEDIATE-OUTPUT MODE. THE CODE HAS NOT
 *                   YET REACHED TOUT.
 *
 *           IDID = 2 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
 *                   COMPLETED (T=TOUT) BY STEPPING EXACTLY TO TOUT.
 *
 *           IDID = 3 -- THE INTEGRATION TO TOUT WAS SUCCESSFULLY
 *                   COMPLETED (T=TOUT) BY STEPPING PAST TOUT.
 *                   Y(*) IS OBTAINED BY INTERPOLATION.
 *                   YPRIME(*) IS OBTAINED BY INTERPOLATION.
 *
 *                    *** TASK INTERRUPTED ***
 *                REPORTED BY NEGATIVE VALUES OF IDID
 *
 *           IDID = -1 -- A LARGE AMOUNT OF WORK HAS BEEN EXPENDED.
 *                   (ABOUT 500 STEPS)
 *
 *           IDID = -2 -- THE ERROR TOLERANCES ARE TOO STRINGENT.
 *
 *           IDID = -3 -- THE LOCAL ERROR TEST CANNOT BE SATISFIED
 *                   BECAUSE YOU SPECIFIED A ZERO COMPONENT IN ATOL
 *                   AND THE CORRESPONDING COMPUTED SOLUTION
 *                   COMPONENT IS ZERO. THUS, A PURE RELATIVE ERROR
 *                   TEST IS IMPOSSIBLE FOR THIS COMPONENT.
 *
 *           IDID = -6 -- DASSL HAD REPEATED ERROR TEST
 *                   FAILURES ON THE LAST ATTEMPTED STEP.
 *
 *           IDID = -7 -- THE CORRECTOR COULD NOT CONVERGE.
 *
 *           IDID = -8 -- THE MATRIX OF PARTIAL DERIVATIVES
 *                   IS SINGULAR.
 *
 *           IDID = -9 -- THE CORRECTOR COULD NOT CONVERGE.
 *                   THERE WERE REPEATED ERROR TEST FAILURES
 *                   IN THIS STEP.
 *
 *           IDID =-10 -- THE CORRECTOR COULD NOT CONVERGE
 *                   BECAUSE IRES WAS EQUAL TO MINUS ONE.
 *
 *           IDID =-11 -- IRES EQUAL TO -2 WAS ENCOUNTERED
 *                   AND CONTROL IS BEING RETURNED TO THE
 *                   CALLING PROGRAM.
 *
 *           IDID =-12 -- DASSL FAILED TO COMPUTE THE INITIAL
 *                   YPRIME.
 *
 *           IDID = -13,..,-32 -- NOT APPLICABLE FOR THIS CODE
 *
 *                    *** TASK TERMINATED ***
 *                REPORTED BY THE VALUE OF IDID=-33
 *
 *           IDID = -33 -- THE CODE HAS ENCOUNTERED TROUBLE FROM WHICH
 *                   IT CANNOT RECOVER. A MESSAGE IS PRINTED
 *                   EXPLAINING THE TROUBLE AND CONTROL IS RETURNED
 *                   TO THE CALLING PROGRAM. FOR EXAMPLE, THIS OCCURS
 *                   WHEN INVALID INPUT IS DETECTED.
 *
 *   RTOL, ATOL -- THESE QUANTITIES REMAIN UNCHANGED EXCEPT WHEN
 *               IDID = -2. IN THIS CASE, THE ERROR TOLERANCES HAVE BEEN
 *               INCREASED BY THE CODE TO VALUES WHICH ARE ESTIMATED TO BE
 *               APPROPRIATE FOR CONTINUING THE INTEGRATION. HOWEVER, THE
 *               REPORTED SOLUTION AT T WAS OBTAINED USING THE INPUT VALUES
 *               OF RTOL AND ATOL.
 *
 *   RWORK, IWORK -- CONTAIN INFORMATION WHICH IS USUALLY OF NO
 *               INTEREST TO THE USER BUT NECESSARY FOR SUBSEQUENT CALLS.
 *               HOWEVER, YOU MAY FIND USE FOR
 *
 *               RWORK(3)--WHICH CONTAINS THE STEP SIZE H TO BE
 *                       ATTEMPTED ON THE NEXT STEP.
 *
 *               RWORK(4)--WHICH CONTAINS THE CURRENT VALUE OF THE
 *                       INDEPENDENT VARIABLE, I.E. THE FARTHEST POINT
 *                       INTEGRATION HAS REACHED. THIS WILL BE DIFFERENT
 *                       FROM T ONLY WHEN INTERPOLATION HAS BEEN
 *                       PERFORMED (IDID=3).
 *
 *               RWORK(7)--WHICH CONTAINS THE STEPSIZE USED
 *                       ON THE LAST SUCCESSFUL STEP.
 *
 *               IWORK(7)--WHICH CONTAINS THE ORDER OF THE METHOD TO
 *                       BE ATTEMPTED ON THE NEXT STEP.
 *
 *               IWORK(8)--WHICH CONTAINS THE ORDER OF THE METHOD USED
 *                       ON THE LAST STEP.
 *
 *               IWORK(11)--WHICH CONTAINS THE NUMBER OF STEPS TAKEN SO FAR.
 *
 *               IWORK(12)--WHICH CONTAINS THE NUMBER OF CALLS TO RES
 *                        SO FAR.
 *
 *               IWORK(13)--WHICH CONTAINS THE NUMBER OF EVALUATIONS OF
 *                        THE MATRIX OF PARTIAL DERIVATIVES NEEDED SO FAR.
 *
 *               IWORK(14)--WHICH CONTAINS THE TOTAL NUMBER
 *                        OF ERROR TEST FAILURES SO FAR.
 *
 *               IWORK(15)--WHICH CONTAINS THE TOTAL NUMBER
 *                        OF CONVERGENCE TEST FAILURES SO FAR.
 *                        (INCLUDES SINGULAR ITERATION MATRIX
 *                        FAILURES.)
 *
 *
 *
 *   INPUT -- WHAT TO DO TO CONTINUE THE INTEGRATION
 *            (CALLS AFTER THE FIRST)                **
 *
 *     THIS CODE IS ORGANIZED SO THAT SUBSEQUENT CALLS TO CONTINUE THE
 *     INTEGRATION INVOLVE LITTLE (IF ANY) ADDITIONAL EFFORT ON YOUR
 *     PART. YOU MUST MONITOR THE IDID PARAMETER IN ORDER TO DETERMINE
 *     WHAT TO DO NEXT.
 *
 *     RECALLING THAT THE PRINCIPAL TASK OF THE CODE IS TO INTEGRATE
 *     FROM T TO TOUT (THE INTERVAL MODE), USUALLY ALL YOU WILL NEED
 *     TO DO IS SPECIFY A NEW TOUT UPON REACHING THE CURRENT TOUT.
 *
 *     DO NOT ALTER ANY QUANTITY NOT SPECIFICALLY PERMITTED BELOW,
 *     IN PARTICULAR DO NOT ALTER NEQ,T,Y(*),YPRIME(*),RWORK(*),IWORK(*)
 *     OR THE DIFFERENTIAL EQUATION IN SUBROUTINE RES. ANY SUCH
 *     ALTERATION CONSTITUTES A NEW PROBLEM AND MUST BE TREATED AS SUCH,
 *     I.E. YOU MUST START AFRESH.
 *
 *     YOU CANNOT CHANGE FROM VECTOR TO SCALAR ERROR CONTROL OR VICE
 *     VERSA (INFO(2)) BUT YOU CAN CHANGE THE SIZE OF THE ENTRIES OF
 *     RTOL, ATOL. INCREASING A TOLERANCE MAKES THE EQUATION EASIER
 *     TO INTEGRATE. DECREASING A TOLERANCE WILL MAKE THE EQUATION
 *     HARDER TO INTEGRATE AND SHOULD GENERALLY BE AVOIDED.
 *
 *     YOU CAN SWITCH FROM THE INTERMEDIATE-OUTPUT MODE TO THE
 *     INTERVAL MODE (INFO(3)) OR VICE VERSA AT ANY TIME.
 *
 *     IF IT HAS BEEN NECESSARY TO PREVENT THE INTEGRATION FROM GOING
 *     PAST A POINT TSTOP (INFO(4), RWORK(1)), KEEP IN MIND THAT THE
 *     CODE WILL NOT INTEGRATE TO ANY TOUT BEYOUND THE CURRENTLY
 *     SPECIFIED TSTOP. ONCE TSTOP HAS BEEN REACHED YOU MUST CHANGE
 *     THE VALUE OF TSTOP OR SET INFO(4)=0. YOU MAY CHANGE INFO(4)
 *     OR TSTOP AT ANY TIME BUT YOU MUST SUPPLY THE VALUE OF TSTOP IN
 *     RWORK(1) WHENEVER YOU SET INFO(4)=1.
 *
 *     DO NOT CHANGE INFO(5), INFO(6), IWORK(1), OR IWORK(2)
 *     UNLESS YOU ARE GOING TO RESTART THE CODE.
 *
 *                    *** FOLLOWING A COMPLETED TASK ***
 *     IF
 *     IDID = 1, CALL THE CODE AGAIN TO CONTINUE THE INTEGRATION
 *                  ANOTHER STEP IN THE DIRECTION OF TOUT.
 *
 *     IDID = 2 OR 3, DEFINE A NEW TOUT AND CALL THE CODE AGAIN.
 *                  TOUT MUST BE DIFFERENT FROM T. YOU CANNOT CHANGE
 *                  THE DIRECTION OF INTEGRATION WITHOUT RESTARTING.
 *
 *                    *** FOLLOWING AN INTERRUPTED TASK ***
 *                  TO SHOW THE CODE THAT YOU REALIZE THE TASK WAS
 *                  INTERRUPTED AND THAT YOU WANT TO CONTINUE, YOU
 *                  MUST TAKE APPROPRIATE ACTION AND SET INFO(1) = 1
 *     IF
 *     IDID = -1, THE CODE HAS TAKEN ABOUT 500 STEPS.
 *                  IF YOU WANT TO CONTINUE, SET INFO(1) = 1 AND
 *                  CALL THE CODE AGAIN. AN ADDITIONAL 500 STEPS
 *                  WILL BE ALLOWED.
 *
 *
 *     IDID = -2, THE ERROR TOLERANCES RTOL, ATOL HAVE BEEN
 *                  INCREASED TO VALUES THE CODE ESTIMATES APPROPRIATE
 *                  FOR CONTINUING. YOU MAY WANT TO CHANGE THEM
 *                  YOURSELF. IF YOU ARE SURE YOU WANT TO CONTINUE
 *                  WITH RELAXED ERROR TOLERANCES, SET INFO(1)=1 AND
 *                  CALL THE CODE AGAIN.
 *
 *     IDID = -3, A SOLUTION COMPONENT IS ZERO AND YOU SET THE
 *                  CORRESPONDING COMPONENT OF ATOL TO ZERO. IF YOU
 *                  ARE SURE YOU WANT TO CONTINUE, YOU MUST FIRST
 *                  ALTER THE ERROR CRITERION TO USE POSITIVE VALUES
 *                  FOR THOSE COMPONENTS OF ATOL CORRESPONDING TO ZERO
 *                  SOLUTION COMPONENTS, THEN SET INFO(1)=1 AND CALL
 *                  THE CODE AGAIN.
 *
 *     IDID = -4,-5  --- CANNOT OCCUR WITH THIS CODE
 *
 *     IDID = -6, REPEATED ERROR TEST FAILURES OCCURRED ON THE
 *                  LAST ATTEMPTED STEP IN DASSL  . A SINGULARITY IN THE
 *                  SOLUTION MAY BE PRESENT. IF YOU ARE ABSOLUTELY
 *                  CERTAIN YOU WANT TO CONTINUE, YOU SHOULD RESTART
 *                  THE INTEGRATION.(PROVIDE INITIAL VALUES OF Y AND
 *                  YPRIME WHICH ARE CONSISTENT)
 *
 *     IDID = -7, REPEATED CONVERGENCE TEST FAILURES OCCURRED
 *                  ON THE LAST ATTEMPTED STEP IN DASSL. AN INACCURATE OR
 *                  ILLCONDITIONED JACOBIAN MAY BE THE PROBLEM. IF YOU
 *                  ARE ABSOLUTELY CERTAIN YOU WANT TO CONTINUE, YOU
 *                  SHOULD RESTART THE INTEGRATION.
 *
 *     IDID = -8, THE MATRIX OF PARTIAL DERIVATIVES IS SINGULAR.
 *                  SOME OF YOUR EQUATIONS MAY BE REDUNDANT.
 *                  DASSL CANNOT SOLVE THE PROBLEM AS STATED.
 *                  IT IS POSSIBLE THAT THE REDUNDANT EQUATIONS
 *                  COULD BE REMOVED, AND THEN DASSL COULD
 *                  SOLVE THE PROBLEM. IT IS ALSO POSSIBLE
 *                  THAT A SOLUTION TO YOUR PROBLEM EITHER
 *                  DOES NOT EXIST OR IS NOT UNIQUE.
 *
 *     IDID = -9, DASSL HAD MULTIPLE CONVERGENCE TEST
 *                  FAILURES, PRECEEDED BY MULTIPLE ERROR
 *                  TEST FAILURES, ON THE LAST ATTEMPTED STEP.
 *                  IT IS POSSIBLE THAT YOUR PROBLEM
 *                  IS ILL-POSED, AND CANNOT BE SOLVED
 *                  USING THIS CODE.  OR, THERE MAY BE A
 *                  DISCONTINUITY OR A SINGULARITY IN THE
 *                  SOLUTION.  IF YOU ARE ABSOLUTELY CERTAIN
 *                  YOU WANT TO CONTINUE, YOU SHOULD RESTART
 *                  THE INTEGRATION.
 *
 *    IDID =-10, DASSL HAD MULTIPLE CONVERGENCE TEST FAILURES
 *                  BECAUSE IRES WAS EQUAL TO MINUS ONE.
 *                  IF YOU ARE ABSOLUTELY CERTAIN YOU WANT
 *                  TO CONTINUE, YOU SHOULD RESTART THE
 *                  INTEGRATION.
 *
 *    IDID =-11, IRES=-2 WAS ENCOUNTERED, AND CONTROL IS BEING
 *                  RETURNED TO THE CALLING PROGRAM.
 *
 *    IDID =-12, DASSL FAILED TO COMPUTE THE INITIAL YPRIME.
 *               THIS COULD HAPPEN BECAUSE THE INITIAL
 *               APPROXIMATION TO YPRIME WAS NOT VERY GOOD, OR
 *               IF A YPRIME CONSISTENT WITH THE INITIAL Y
 *               DOES NOT EXIST.  THE PROBLEM COULD ALSO BE CAUSED
 *               BY AN INACCURATE OR SINGULAR ITERATION MATRIX.
 *
 *
 *
 *     IDID = -13,..,-32 --- CANNOT OCCUR WITH THIS CODE
 *
 *                       *** FOLLOWING A TERMINATED TASK ***
 *     IF IDID= -33, YOU CANNOT CONTINUE THE SOLUTION OF THIS
 *                  PROBLEM. AN ATTEMPT TO DO SO WILL RESULT IN YOUR
 *                  RUN BEING TERMINATED.
 *
 *  ---------------------------------------------------------------------
 *
 ****REFERENCES  A DESCRIPTION OF DASSL: A DIFFERENTIAL/ALGEBRAIC
 *                  SYSTEM SOLVER, L. R. PETZOLD, SAND82-8637,
 *                  SANDIA NATIONAL LABORATORIES, SEPTEMBER 1982.
 ****ROUTINES CALLED  DDASTP,DDAINI,DDANRM,DDAWTS,DDATRP,XERRWV,D1MACH
 ****COMMON BLOCKS    DDA001
 ****END PROLOGUE DASSL
 *
 */

//////////////////////////////////////////////////////////////////////////////

#endif

//////////////////////////////////////////////////////////////////////////////

